<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miracle_DZL的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-07T10:48:47.729Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>miracle_DZL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.1递归</title>
    <link href="http://yoursite.com/2019/11/04/2.1%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2019/11/04/2.1递归/</id>
    <published>2019-11-04T13:46:57.720Z</published>
    <updated>2019-11-07T10:48:47.729Z</updated>
    
    <content type="html"><![CDATA[<p>2.1递归</p><p>概念：直接或间接的调用自身的算法成为递归算法。用函数自身给出定义的函数成为递归函数。</p><p>2-1阶乘函数。阶乘函数可递归的定义为<a id="more"></a></p><p>​        n！= 1（n = 0）/ n*(n-1)! (n&gt;0)</p><p>递归的特变：</p><p>1.每个递归函数都必须有非递归定义的初始值，如上式n=0，n!=1.</p><p>2.第二式用较小自变量的函数值来表示较大自变量的函数值来定义n的阶乘</p><p>3.要有临界条件</p><p>例2-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//factorial 阶乘 阶乘的 因子的</span><br><span class="line">int factorial(int n) &#123;</span><br><span class="line">if (n == 0)</span><br><span class="line">return 1;</span><br><span class="line">return n*factorial(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2-2 斐波那契数列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">无穷数列：1,1,2,3,5,8,13,21,34......</span><br><span class="line">递归定义为</span><br><span class="line">    1                   x = 0</span><br><span class="line">f(x) =  1                   x = 1</span><br><span class="line">           f(x-1) + (x-2)      x &gt; 1</span><br><span class="line">*/</span><br><span class="line">int fibonacci(int n) &#123;</span><br><span class="line">if (n &lt;= 1)</span><br><span class="line">return 1;</span><br><span class="line">return fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2-3 Ackerman函数（双递归）</p><p><img src="C:%5CUsers%5CDZL%5CPictures%5C%E5%8D%9A%E5%AE%A2%5C1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int ack(int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(m == 0)</span><br><span class="line">        return n+1;</span><br><span class="line">    else if(n == 0)</span><br><span class="line">        return ack(m-1,1);</span><br><span class="line">    else</span><br><span class="line">        return ack(m-1,ack(m,n-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2-4  全排列问题</p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p><a href="http://q0lhqnf0a.bkt.clouddn.com/1.png" target="_blank" rel="noopener">http://q0lhqnf0a.bkt.clouddn.com/1.png</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Perm(Type list[],int k,int m) &#123;    </span><br><span class="line">if (k == m)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; list[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">for (int i = k; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">Swap(int k,int m);</span><br><span class="line">Perm(list,k+1,m);</span><br><span class="line">Swap(int k,int m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(Type &amp;a,Type &amp;b) &#123;</span><br><span class="line">Type temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.1递归&lt;/p&gt;
&lt;p&gt;概念：直接或间接的调用自身的算法成为递归算法。用函数自身给出定义的函数成为递归函数。&lt;/p&gt;
&lt;p&gt;2-1阶乘函数。阶乘函数可递归的定义为
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>因为热爱</title>
    <link href="http://yoursite.com/2019/10/28/%E5%9B%A0%E4%B8%BA%E7%83%AD%E7%88%B1/"/>
    <id>http://yoursite.com/2019/10/28/因为热爱/</id>
    <published>2019-10-28T12:05:11.304Z</published>
    <updated>2019-11-06T11:31:13.919Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:博客的第一次开通</p><hr><p>欢迎大家来到我的博客，我非常高兴，能在博客分享自己的故事与经历，或许能帮助大家。</p><h2 id="所谓热爱，就是不断的坚持和投入"><a href="#所谓热爱，就是不断的坚持和投入" class="headerlink" title="所谓热爱，就是不断的坚持和投入"></a>所谓热爱，就是不断的坚持和投入<a id="more"></a></h2><p>你会不会买一本书，其实你从来不看，但是你觉得好像拥有了其中的知识？你会不会制定了一个计划，其实你从来坚持不下来，只是享受制订计划那几天的快乐？</p><p>　　我们总是习惯了这样的开始，然后又寥寥草草的结束。对事如此，对待生活也是如此，当一个人对自己的<a href="https://www.lz13.cn/mingrenmingyan/8609.html" target="_blank" rel="noopener">生命</a>开始用“潦草”来搪塞时，生命也会开始对他潦草。</p><p>　　如果跳舞，要像没有人看着那样尽兴；如果热恋，像从未受伤一样去爱；如果唱歌，像无人听着那样投入；如果活着，就把人间当天堂那般生活。</p><p>　　这个世界上有很多事，都是当你开始认真对待以后，才会发现其中包含的乐趣，你要带着关爱而不是期待地投入生活，当你对待事物越认真，对待工作越投入，你会发现能力与乐趣接踵而来。</p><p>　　因为所谓的热爱，其实就是不断的坚持和投入。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:博客的第一次开通&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;欢迎大家来到我的博客，我非常高兴，能在博客分享自己的故事与经历，或许能帮助大家。&lt;/p&gt;
&lt;h2 id=&quot;所谓热爱，就是不断的坚持和投入&quot;&gt;&lt;a href=&quot;#所谓热爱，就是不断的坚持和投入&quot; class=&quot;headerlink&quot; title=&quot;所谓热爱，就是不断的坚持和投入&quot;&gt;&lt;/a&gt;所谓热爱，就是不断的坚持和投入
    
    </summary>
    
    
    
  </entry>
  
</feed>
