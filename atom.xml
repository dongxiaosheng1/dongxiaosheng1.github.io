<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miracle_DZL的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-11T03:03:23.934Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>miracle_DZL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tomcat报错 java.lang.AbstractMethodError</title>
    <link href="http://yoursite.com/2020/04/03/tomcat%E6%8A%A5%E9%94%99%20java.lang.AbstractMethodError/"/>
    <id>http://yoursite.com/2020/04/03/tomcat报错 java.lang.AbstractMethodError/</id>
    <published>2020-04-03T01:14:49.190Z</published>
    <updated>2020-04-11T03:03:23.934Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1555911599-e70784b1e21d?ixlib=rb-1.2.1&q=99&fm=jpg&crop=entropy&cs=tinysrgb&w=2048&fit=max&ixid=eyJhcHBfaWQiOjcwOTV9" alt="mark"></p><h2 id="java-lang-AbstractMethodError-javax-servlet-jsp-JspFactory-getJspApplicationContext-Ljavax-servlet"><a href="#java-lang-AbstractMethodError-javax-servlet-jsp-JspFactory-getJspApplicationContext-Ljavax-servlet" class="headerlink" title="java.lang.AbstractMethodError: javax.servlet.jsp.JspFactory.getJspApplicationContext(Ljavax/servlet/"></a>java.lang.AbstractMethodError: javax.servlet.jsp.JspFactory.getJspApplicationContext(Ljavax/servlet/<a id="more"></a></h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200403/N8gKuiG0xIgo.png?imageslim" alt="mark"></h2><p>当遇到这个错误时，我仔细思考并查找发现是项目的lib包下，jasper-compiler.jar &amp; jasper-runtime.jar &amp;  servlet-api.jar删除就行，其实是我前一天导入部署了老师给的一个web项目,其中项目webinf下的lib目录中上边的jar包与tomcat的jar包重复冲突。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1555911599-e70784b1e21d?ixlib=rb-1.2.1&amp;q=99&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2048&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjcwOTV9&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-lang-AbstractMethodError-javax-servlet-jsp-JspFactory-getJspApplicationContext-Ljavax-servlet&quot;&gt;&lt;a href=&quot;#java-lang-AbstractMethodError-javax-servlet-jsp-JspFactory-getJspApplicationContext-Ljavax-servlet&quot; class=&quot;headerlink&quot; title=&quot;java.lang.AbstractMethodError: javax.servlet.jsp.JspFactory.getJspApplicationContext(Ljavax/servlet/&quot;&gt;&lt;/a&gt;java.lang.AbstractMethodError: javax.servlet.jsp.JspFactory.getJspApplicationContext(Ljavax/servlet/
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>超星自动播放</title>
    <link href="http://yoursite.com/2020/03/31/%E8%B6%85%E6%98%9F%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2020/03/31/超星自动播放/</id>
    <published>2020-03-31T10:49:22.619Z</published>
    <updated>2020-03-31T10:51:26.424Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习 天天向上</p><p>说明：谷歌浏览器按F12在console中输入以上代码 回车完成</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">var fa = $(&quot;body&quot;);</span><br><span class="line">var btn = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;);</span><br><span class="line">var json = &#123;</span><br><span class="line">    &quot;background&quot;: &quot;#31e16d&quot;,</span><br><span class="line">    &quot;height&quot;: &quot;16px&quot;,</span><br><span class="line">    &quot;padding&quot;: &quot;5px&quot;,</span><br><span class="line">    &quot;z-index&quot;: 999999,</span><br><span class="line">    &quot;cursor&quot;: &quot;pointer&quot;,</span><br><span class="line">    &quot;top&quot;: &quot;300px&quot;,</span><br><span class="line">    &quot;right&quot;: &quot;120px&quot;,</span><br><span class="line">    &quot;position&quot;: &quot;fixed&quot;</span><br><span class="line">&#125;;</span><br><span class="line">btn.css(json);</span><br><span class="line">btn.html(&quot;&lt;span id=&apos;lfsenior&apos;&gt;开启自动播放模式&lt;/span&gt;&quot;);</span><br><span class="line">fa.append(btn);</span><br><span class="line"> </span><br><span class="line">btn.click(function () &#123;</span><br><span class="line"> </span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        //获取iframe</span><br><span class="line">        var video = $(&quot;iframe&quot;).contents().find(&quot;iframe&quot;).contents();</span><br><span class="line">        //播放函数</span><br><span class="line">        var play = function () &#123;</span><br><span class="line">            video.find(&quot;#video &gt; button&quot;).click();</span><br><span class="line">            var jy = video.find(&quot;#video &gt; div.vjs-control-bar &gt; div.vjs-volume-panel.vjs-control.vjs-volume-panel-vertical &gt; button&quot;);</span><br><span class="line">            if (jy.attr(&quot;title&quot;) != &quot;取消静音&quot;) &#123;</span><br><span class="line">                jy.click()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果正在加载</span><br><span class="line">        var load = video.find(&quot;#loading&quot;);</span><br><span class="line">        if (load.css(&quot;visibility&quot;) != &quot;hidden&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取当前进度</span><br><span class="line">        var spans = video.find(&quot;#video &gt; div.vjs-control-bar &gt; div.vjs-progress-control.vjs-control &gt; div&quot;).attr(&quot;aria-valuenow&quot;);</span><br><span class="line">        // 如果还没播放完</span><br><span class="line">        if (spans != 100) &#123;</span><br><span class="line">            play();</span><br><span class="line">        &#125;</span><br><span class="line">        //如果播放结束</span><br><span class="line">        if (spans == 100) &#123;</span><br><span class="line">            var bs = false;</span><br><span class="line">            $(&quot;.onetoone&quot;).find(&quot;.flush&quot;).each(function () &#123;</span><br><span class="line">                if (bs) &#123;</span><br><span class="line">                    $(this).prev(&quot;a&quot;).on(&apos;click&apos;, &quot;#coursetree&gt;ncells&quot;, function () &#123;</span><br><span class="line">                        console.log(&quot;已结束章节：&quot; + $(this).prev(&quot;a&quot;).attr(&quot;title&quot;))</span><br><span class="line">                    &#125;)</span><br><span class="line">                    var str = $(this).prev(&quot;a&quot;).attr(&quot;href&quot;);</span><br><span class="line">                    str = str.match(/&apos;(\S*)&apos;/)[1];</span><br><span class="line">                    var reg = new RegExp(&quot;&apos;&quot;, &quot;g&quot;);</span><br><span class="line">                    str = str.replace(reg, &quot;&quot;);</span><br><span class="line">                    var href = str.split(&quot;,&quot;);</span><br><span class="line">                    getTeacherAjax(href[0], href[1], href[2])</span><br><span class="line">                    bs = false;</span><br><span class="line">                &#125;</span><br><span class="line">                if ($(this).css(&quot;display&quot;) == &quot;block&quot;) &#123;</span><br><span class="line">                    bs = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        $(&quot;#lfsenior&quot;).html(&quot;自动模式已开启,本章进度:&quot; + spans + &quot;%&quot;);</span><br><span class="line">    &#125;, 100);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习 天天向上&lt;/p&gt;
&lt;p&gt;说明：谷歌浏览器按F12在console中输入以上代码 回车完成&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Filter&amp;Listener笔记</title>
    <link href="http://yoursite.com/2020/03/31/Filter&amp;Listener%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/Filter&amp;Listener笔记/</id>
    <published>2020-03-30T23:59:54.789Z</published>
    <updated>2020-03-31T00:04:44.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. Filter：过滤器2. Listener：监听器</code></pre><h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器<a id="more"></a></h1><pre><code>1. 概念：    * 生活中的过滤器：净水器,空气净化器，土匪、    * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。    * 过滤器的作用：        * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...2. 快速入门：    1. 步骤：        1. 定义一个类，实现接口Filter        2. 复写方法        3. 配置拦截路径            1. web.xml            2. 注解    2. 代码：        @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器        public class FilterDemo1 implements Filter {            @Override            public void init(FilterConfig filterConfig) throws ServletException {            }            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {                System.out.println(&quot;filterDemo1被执行了....&quot;);</code></pre><p>​<br>                    //放行<br>                    filterChain.doFilter(servletRequest,servletResponse);</p><pre><code>            }            @Override            public void destroy() {            }        }3. 过滤器细节：    1. web.xml配置            &lt;filter&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;        &lt;/filter&gt;        &lt;filter-mapping&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;!-- 拦截路径 --&gt;            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;        &lt;/filter-mapping&gt;    2. 过滤器执行流程        1. 执行过滤器        2. 执行放行后的资源        3. 回来执行过滤器放行代码下边的代码    3. 过滤器生命周期方法        1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源        2. doFilter:每一次请求被拦截资源时，会执行。执行多次        3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源    4. 过滤器配置详解        * 拦截路径配置：            1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行            2. 拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行            3. 后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行            4. 拦截所有资源：/*        访问所有资源时，过滤器都会被执行        * 拦截方式配置：资源被访问的方式            * 注解配置：                * 设置dispatcherTypes属性                    1. REQUEST：默认值。浏览器直接请求资源                    2. FORWARD：转发访问资源                    3. INCLUDE：包含访问资源                    4. ERROR：错误跳转资源                    5. ASYNC：异步访问资源            * web.xml配置                * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可    5. 过滤器链(配置多个过滤器)        * 执行顺序：如果有两个过滤器：过滤器1和过滤器2            1. 过滤器1            2. 过滤器2            3. 资源执行            4. 过滤器2            5. 过滤器1         * 过滤器先后顺序问题：            1. 注解配置：按照类名的字符串比较规则比较，值小的先执行                * 如： AFilter 和 BFilter，AFilter就先执行了。            2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行4. 案例：    1. 案例1_登录验证        * 需求：            1. 访问day17_case案例的资源。验证其是否登录            2. 如果登录了，则直接放行。            3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。</code></pre><p>​    </p><pre><code>2. 案例2_敏感词汇过滤    * 需求：        1. 对day17_case案例录入的数据进行敏感词汇过滤        2. 敏感词汇参考《敏感词汇.txt》        3. 如果是敏感词汇，替换为 ***     * 分析：        1. 对request对象进行增强。增强获取参数相关方法        2. 放行。传递代理对象    * 增强对象的功能：        * 设计模式：一些通用的解决固定问题的方式        1. 装饰模式        2. 代理模式            * 概念：                1. 真实对象：被代理的对象                2. 代理对象：                3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的             * 实现方式：                 1. 静态代理：有一个类文件描述代理模式                 2. 动态代理：在内存中形成代理类                    * 实现步骤：                        1. 代理对象和真实对象实现相同的接口                        2. 代理对象 = Proxy.newProxyInstance();                        3. 使用代理对象调用方法。                        4. 增强方法                    * 增强方式：                        1. 增强参数列表                        2. 增强返回值类型                        3. 增强方法体执行逻辑    </code></pre><h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><pre><code>* 概念：web的三大组件之一。    * 事件监听机制        * 事件    ：一件事情        * 事件源 ：事件发生的地方        * 监听器 ：一个对象        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码* ServletContextListener:监听ServletContext对象的创建和销毁    * 方法：        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法    * 步骤：        1. 定义一个类，实现ServletContextListener接口        2. 复写方法        3. 配置            1. web.xml                    &lt;listener&gt;                      &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;                       &lt;/listener&gt;                    * 指定初始化参数&lt;context-param&gt;            2. 注解：                * @WebListener</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. Filter：过滤器
2. Listener：监听器&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Filter：过滤器&quot;&gt;&lt;a href=&quot;#Filter：过滤器&quot; class=&quot;headerlink&quot; title=&quot;Filter：过滤器&quot;&gt;&lt;/a&gt;Filter：过滤器
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>综合练习笔记</title>
    <link href="http://yoursite.com/2020/03/31/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/综合练习笔记/</id>
    <published>2020-03-30T23:59:45.496Z</published>
    <updated>2020-03-31T02:37:59.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 综合练习    1. 简单功能        1. 列表查询        2. 登录        3. 添加        4. 删除        5. 修改    2. 复杂功能        1. 删除选中        2. 分页查询            * 好处：                1. 减轻服务器内存的开销                2. 提升用户体验        3. 复杂条件查询</code></pre><a id="more"></a><h2 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h2><pre><code>1. 调整页面，加入验证码功能2. 代码实现</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 综合练习
    1. 简单功能
        1. 列表查询
        2. 登录
        3. 添加
        4. 删除
        5. 修改

    2. 复杂功能
        1. 删除选中
        2. 分页查询
            * 好处：
                1. 减轻服务器内存的开销
                2. 提升用户体验
        3. 复杂条件查询&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>EL&amp;JSTL笔记</title>
    <link href="http://yoursite.com/2020/03/31/EL&amp;JSTL%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/EL&amp;JSTL笔记/</id>
    <published>2020-03-30T23:59:34.942Z</published>
    <updated>2020-03-31T02:37:45.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JSP:    1. 指令    2. 注释    3. 内置对象2. MVC开发模式3. EL表达式4. JSTL标签5. 三层架构</code></pre><a id="more"></a><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP:"></a>JSP:</h2><pre><code>1. 指令    * 作用：用于配置JSP页面，导入资源文件    * 格式：        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;    * 分类：        1. page        ： 配置JSP页面的            * contentType：等同于response.setContentType()                1. 设置响应体的mime类型以及字符集                2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）            * import：导包            * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面            * isErrorPage：标识当前也是是否是错误页面。                * true：是，可以使用内置对象exception                * false：否。默认值。不可以使用内置对象exception        2. include    ： 页面包含的。导入页面的资源文件            * &lt;%@include file=&quot;top.jsp&quot;%&gt;        3. taglib    ： 导入资源            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;                * prefix：前缀，自定义的2. 注释:    1. html注释：        &lt;!-- --&gt;:只能注释html代码片段    2. jsp注释：推荐使用        &lt;%-- --%&gt;：可以注释所有3. 内置对象    * 在jsp页面中不需要创建，直接使用的对象    * 一共有9个：            变量名                    真实类型                        作用        * pageContext                PageContext                    当前页面共享数据，还可以获取其他八个内置对象        * request                    HttpServletRequest            一次请求访问的多个资源(转发)        * session                    HttpSession                    一次会话的多个请求间        * application                ServletContext                所有用户间共享数据        * response                    HttpServletResponse            响应对象        * page                        Object                        当前页面(Servlet)的对象  this        * out                        JspWriter                    输出对象，数据输出到页面上        * config                    ServletConfig                Servlet的配置对象        * exception                    Throwable                    异常对象</code></pre><p>​    </p><h2 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h2><pre><code>1. jsp演变历史    1. 早期只有servlet，只能使用response输出标签数据，非常麻烦    2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作    3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性2. MVC：    1. M：Model，模型。JavaBean        * 完成具体的业务操作，如：查询数据库，封装对象    2. V：View，视图。JSP        * 展示数据    3. C：Controller，控制器。Servlet        * 获取用户的输入        * 调用模型        * 将数据交给视图进行展示    * 优缺点：        1. 优点：            1. 耦合性低，方便维护，可以利于分工协作            2. 重用性高        2. 缺点：            1. 使得项目架构变得复杂，对开发人员要求高</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：${表达式}4. 注意：    * jsp默认支持el表达式的。如果要忽略el表达式        1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式        2. \${表达式} ：忽略当前这个el表达式5. 使用：    1. 运算：        * 运算符：            1. 算数运算符： + - * /(div) %(mod)            2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=            3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)            4. 空运算符： empty                * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0                * ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0                * ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0    2. 获取值        1. el表达式只能从域对象中获取值        2. 语法：            1. ${域名称.键名}：从指定域中获取指定键的值                * 域名称：                    1. pageScope        --&gt; pageContext                    2. requestScope     --&gt; request                    3. sessionScope     --&gt; session                    4. applicationScope --&gt; application（ServletContext）                * 举例：在request域中存储了name=张三                * 获取：${requestScope.name}            2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</code></pre><p>​<br>​<br>​                3. 获取对象、List集合、Map集合的值<br>​                    1. 对象：${域名称.键名.属性名}<br>​                        * 本质上会去调用对象的getter方法<br>​<br>​                    2. List集合：${域名称.键名[索引]}<br>​<br>                    3. Map集合：<br>                        * ${域名称.键名.key名称}<br>                        * ${域名称.键名[“key名称”]}</p><pre><code>3. 隐式对象：    * el表达式中有11个隐式对象    * pageContext：        * 获取jsp其他八个内置对象            * ${pageContext.request.contextPath}：动态获取虚拟目录</code></pre><p>​    </p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><pre><code>1. 概念：JavaServer Pages Tag Library  JSP标准标签库    * 是由Apache组织提供的开源的免费的jsp标签        &lt;标签&gt;2. 作用：用于简化和替换jsp页面上的java代码        3. 使用步骤：    1. 导入jstl相关jar包    2. 引入标签库：taglib指令：  &lt;%@ taglib %&gt;    3. 使用标签4. 常用的JSTL标签    1. if:相当于java代码的if语句        1. 属性：            * test 必须属性，接受boolean表达式                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容                * 一般情况下，test属性值会结合el表达式一起使用            2. 注意：                * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签    2. choose:相当于java代码的switch语句        1. 使用choose标签声明                     相当于switch声明        2. 使用when标签做判断                     相当于case        3. 使用otherwise标签做其他情况的声明        相当于default    3. foreach:相当于java代码的for语句5. 练习：    * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中</code></pre><h2 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h2><pre><code>1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互2. 业务逻辑层：处理业务逻辑的。3. 数据访问层：操作数据存储文件。</code></pre><h2 id="案例：用户信息列表展示"><a href="#案例：用户信息列表展示" class="headerlink" title="案例：用户信息列表展示"></a>案例：用户信息列表展示</h2><pre><code>1. 需求：用户信息的增删改查操作2. 设计：    1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat    2. 数据库设计：        create database day17; -- 创建数据库        use day17;                -- 使用数据库        create table user(   -- 创建表            id int primary key auto_increment,            name varchar(20) not null,            gender varchar(5),            age int,            address varchar(32),            qq    varchar(20),            email varchar(50)        );3. 开发：    1. 环境搭建        1. 创建数据库环境        2. 创建项目，导入需要的jar包    2. 编码4. 测试5. 部署运维</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. JSP:
    1. 指令
    2. 注释
    3. 内置对象
2. MVC开发模式
3. EL表达式
4. JSTL标签
5. 三层架构&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cookie&amp;Session笔记</title>
    <link href="http://yoursite.com/2020/03/31/Cookie&amp;Session%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/Cookie&amp;Session笔记/</id>
    <published>2020-03-30T23:59:25.418Z</published>
    <updated>2020-03-31T00:04:13.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 会话技术    1. Cookie    2. Session2. JSP：入门学习</code></pre><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术<a id="more"></a></h2><pre><code>1. 会话：一次会话中包含多次请求和响应。    * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止2. 功能：在一次会话的范围内的多次请求间，共享数据3. 方式：    1. 客户端会话技术：Cookie    2. 服务器端会话技术：Session</code></pre><h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><pre><code>1. 概念：客户端会话技术，将数据保存到客户端2. 快速入门：    * 使用步骤：        1. 创建Cookie对象，绑定数据            * new Cookie(String name, String value)         2. 发送Cookie对象            * response.addCookie(Cookie cookie)         3. 获取Cookie，拿到数据            * Cookie[]  request.getCookies()  3. 实现原理    * 基于响应头set-cookie和请求头cookie实现4. cookie的细节    1. 一次可不可以发送多个cookie?        * 可以        * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。    2. cookie在浏览器中保存多长时间？        1. 默认情况下，当浏览器关闭后，Cookie数据被销毁        2. 持久化存储：            * setMaxAge(int seconds)                1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效                2. 负数：默认值                3. 零：删除cookie信息    3. cookie能不能存中文？        * 在tomcat 8 之前 cookie中不能直接存储中文数据。            * 需要将中文数据转码---一般采用URL编码(%E3)        * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析    4. cookie共享问题？        1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？            * 默认情况下cookie不能共享            * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录                * 如果要共享，则可以将path设置为&quot;/&quot;</code></pre><p>​<br>            2. 不同的tomcat服务器间cookie共享问题？<br>                * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享<br>                    * setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p><pre><code>5. Cookie的特点和作用    1. cookie存储数据在客户端浏览器    2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)    * 作用：        1. cookie一般用于存出少量的不太敏感的数据        2. 在不登录的情况下，完成服务器对客户端的身份识别6. 案例：记住上一次访问时间    1. 需求：        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串    2. 分析：        1. 可以采用Cookie来完成        2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie            1. 有：不是第一次访问                1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20                2. 写回Cookie：lastTime=2018年6月10日11:50:01            2. 没有：是第一次访问                1. 响应数据：您好，欢迎您首次访问                2. 写回Cookie：lastTime=2018年6月10日11:50:01    3. 代码实现：        package cn.itcast.cookie;        import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.Cookie;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;        import java.net.URLDecoder;        import java.net.URLEncoder;        import java.text.SimpleDateFormat;        import java.util.Date;    @WebServlet(&quot;/cookieTest&quot;)    public class CookieTest extends HttpServlet {        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            //设置响应的消息体的数据格式以及编码            response.setContentType(&quot;text/html;charset=utf-8&quot;);            //1.获取所有Cookie            Cookie[] cookies = request.getCookies();            boolean flag = false;//没有cookie为lastTime            //2.遍历cookie数组            if(cookies != null &amp;&amp; cookies.length &gt; 0){                for (Cookie cookie : cookies) {                    //3.获取cookie的名称                    String name = cookie.getName();                    //4.判断名称是否是：lastTime                    if(&quot;lastTime&quot;.equals(name)){                        //有该Cookie，不是第一次访问                        flag = true;//有lastTime的cookie                        //设置Cookie的value                        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                        Date date  = new Date();                        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                        String str_date = sdf.format(date);                        System.out.println(&quot;编码前：&quot;+str_date);                        //URL编码                        str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                        System.out.println(&quot;编码后：&quot;+str_date);                        cookie.setValue(str_date);                        //设置cookie的存活时间                        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                        response.addCookie(cookie);</code></pre><p>​<br>                            //响应数据<br>                            //获取Cookie的value，时间<br>                            String value = cookie.getValue();<br>                            System.out.println(“解码前：”+value);<br>                            //URL解码：<br>                            value = URLDecoder.decode(value,”utf-8”);<br>                            System.out.println(“解码后：”+value);<br>                            response.getWriter().write(“<h1>欢迎回来，您上次访问时间为:”+value+”</h1>“);</p><pre><code>            break;        }    }}</code></pre><p>​<br>                if(cookies == null || cookies.length == 0 || flag == false){<br>                    //没有，第一次访问</p><pre><code>    //设置Cookie的value    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie    Date date  = new Date();    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);    String str_date = sdf.format(date);    System.out.println(&quot;编码前：&quot;+str_date);    //URL编码    str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);    System.out.println(&quot;编码后：&quot;+str_date);    Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);    //设置cookie的存活时间    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月    response.addCookie(cookie);    response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;);}</code></pre><p>​<br>            }</p><pre><code>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h2 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h2><pre><code>1. 概念：    * Java Server Pages： java服务器端页面        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码        * 用于简化书写！！！2. 原理    * JSP本质上就是一个Servlet3. JSP的脚本：JSP定义Java代码的方式    1. &lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。    2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。    3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。4. JSP的内置对象：    * 在jsp页面中不需要获取和创建，可以直接使用的对象    * jsp一共有9个内置对象。    * 今天学习3个：        * request        * response        * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似            * response.getWriter()和out.write()的区别：                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。                * response.getWriter()数据输出永远在out.write()之前5. 案例:改造Cookie案例</code></pre><h2 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h2><pre><code>1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession2. 快速入门：    1. 获取HttpSession对象：        HttpSession session = request.getSession();    2. 使用HttpSession对象：        Object getAttribute(String name)          void setAttribute(String name, Object value)        void removeAttribute(String name)  3. 原理    * Session的实现是依赖于Cookie的。</code></pre><p>​<br>    4. 细节：<br>        1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？<br>            * 默认情况下。不是。<br>            * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。<br>                 Cookie c = new Cookie(“JSESSIONID”,session.getId());<br>                 c.setMaxAge(60*60);<br>                 response.addCookie(c);</p><pre><code>   2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？       * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作           * session的钝化：               * 在服务器正常关闭之前，将session对象系列化到硬盘上           * session的活化：               * 在服务器启动后，将session文件转化为内存中的session对象即可。   3. session什么时候被销毁？       1. 服务器关闭       2. session对象调用invalidate() 。       3. session默认失效时间 30分钟           选择性配置修改               &lt;session-config&gt;               &lt;session-timeout&gt;30&lt;/session-timeout&gt;           &lt;/session-config&gt;5. session的特点    1. session用于存储一次会话的多次请求的数据，存在服务器端    2. session可以存储任意类型，任意大小的数据   * session与Cookie的区别：       1. session存储数据在服务器端，Cookie在客户端       2. session没有数据大小限制，Cookie有       3. session数据安全，Cookie相对于不安全</code></pre><h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2><pre><code>1. 案例需求：    1. 访问带有验证码的登录页面login.jsp    2. 用户输入用户名，密码以及验证码。        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误        * 如果验证码输入有误，跳转登录页面，提示：验证码错误        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您2. 分析：</code></pre><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 会话技术
    1. Cookie
    2. Session
2. JSP：入门学习&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;会话技术&quot;&gt;&lt;a href=&quot;#会话技术&quot; class=&quot;headerlink&quot; title=&quot;会话技术&quot;&gt;&lt;/a&gt;会话技术
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Response笔记</title>
    <link href="http://yoursite.com/2020/03/31/Response%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/Response笔记/</id>
    <published>2020-03-30T23:59:14.219Z</published>
    <updated>2020-03-31T02:36:09.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. HTTP协议：响应消息2. Response对象3. ServletContext对象</code></pre><a id="more"></a><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><pre><code>1. 请求消息：客户端发送给服务器端的数据    * 数据格式：        1. 请求行        2. 请求头        3. 请求空行        4. 请求体2. 响应消息：服务器端发送给客户端的数据    * 数据格式：        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。                1. 状态码都是3位数字                 2. 分类：                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404（请求路径没有对应的资源）                             * 405：请求方式没有对应的doXxx方法                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)</code></pre><p>​<br>​            2. 响应头：<br>​                1. 格式：头名称： 值<br>​                2. 常见的响应头：<br>​                    1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式<br>​                    2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据<br>​                        * 值：<br>​                            * in-line:默认值,在当前页面内打开<br>​                            * attachment;filename=xxx：以附件形式打开响应体。文件下载<br>​            3. 响应空行<br>​            4. 响应体:传输的数据</p><pre><code>* 响应字符串格式    HTTP/1.1 200 OK    Content-Type: text/html;charset=UTF-8    Content-Length: 101    Date: Wed, 06 Jun 2018 07:08:42 GMT    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;$Title$&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;      hello , response      &lt;/body&gt;    &lt;/html&gt;</code></pre><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)     2. 设置响应头：setHeader(String name, String value)     3. 设置响应体：        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器* 案例：    1. 完成重定向        * 重定向：资源跳转的方式        * 代码实现：            //1. 设置状态码为302            response.setStatus(302);            //2.设置响应头location            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);            //简单的重定向方法            response.sendRedirect(&quot;/day15/responseDemo2&quot;);        * 重定向的特点:redirect            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求。不能使用request对象来共享数据        * 转发的特点：forward            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用request对象来共享数据        * forward 和  redirect 区别        * 路径写法：            1. 路径分类                1. 相对路径：通过相对路径不可以确定唯一资源                    * 如：./index.html                    * 不以/开头，以.开头路径                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../:后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt; , &lt;form&gt; 重定向...                        * 给服务器使用：不需要加虚拟目录                            * 转发路径</code></pre><p>​<br>​                        </p><pre><code>2. 服务器输出字符数据到浏览器    * 步骤：        1. 获取字符输出流        2. 输出数据    * 注意：        * 乱码问题：            1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1            2. 设置该流的默认编码            3. 告诉浏览器响应体使用的编码            //简单的形式，设置编码，是在获取流之前设置            response.setContentType(&quot;text/html;charset=utf-8&quot;);3. 服务器输出字节数据到浏览器    * 步骤：        1. 获取字节输出流        2. 输出数据4. 验证码    1. 本质：图片    2. 目的：防止恶意表单注册</code></pre><h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取：    1. 通过request对象获取        request.getServletContext();    2. 通过HttpServlet获取        this.getServletContext();3. 功能：    1. 获取MIME类型：        * MIME类型:在互联网通信过程中定义的一种文件数据类型            * 格式： 大类型/小类型   text/html        image/jpeg        * 获取：String getMimeType(String file)      2. 域对象：共享数据        1. setAttribute(String name,Object value)        2. getAttribute(String name)        3. removeAttribute(String name)        * ServletContext对象范围：所有用户所有请求的数据    3. 获取文件的真实(服务器)路径        1. 方法：String getRealPath(String path)               String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问             System.out.println(b);            String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问            System.out.println(c);            String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问            System.out.println(a);</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：    1. 页面显示超链接    2. 点击超链接后弹出下载提示框    3. 完成图片文件下载* 分析：    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求    2. 任何资源都必须弹出下载提示框    3. 使用响应头设置资源的打开方式：        * content-disposition:attachment;filename=xxx* 步骤：    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename    2. 定义Servlet        1. 获取文件名称        2. 使用字节输入流加载文件进内存        3. 指定response的响应头： content-disposition:attachment;filename=xxx        4. 将数据写出到response输出流* 问题：    * 中文文件问题        * 解决思路：            1. 获取客户端使用的浏览器版本信息            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. HTTP协议：响应消息
2. Response对象
3. ServletContext对象&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Servlet&amp;HTTP&amp;Request笔记</title>
    <link href="http://yoursite.com/2020/03/31/Servlet&amp;HTTP&amp;Request%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/Servlet&amp;HTTP&amp;Request笔记/</id>
    <published>2020-03-30T23:59:05.223Z</published>
    <updated>2020-03-31T00:06:09.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. Servlet2. HTTP协议3. Request</code></pre><a id="more"></a><h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构        Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre><h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><pre><code>* 概念：Hyper Text Transfer Protocol 超文本传输协议    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点：        1. 基于TCP/IP的高级协议        2. 默认端口号:80        3. 基于请求/响应模型的:一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每一次请求响应都会建立新的连接        * 1.1：复用连接* 请求消息数据格式    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html    HTTP/1.1        * 请求方式：            * HTTP协议有7中请求方式，常用的有2种                * GET：                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST：                    1. 请求参数在请求体中                    2. 请求的url长度没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头：            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Referer：http://localhost/login.html                * 告诉服务器，我(当前请求)从哪里来？                    * 作用：                        1. 防盗链：                        2. 统计工作：    3. 请求空行        空行，就是用于分割POST请求的请求头，和请求体的。    4. 请求体(正文)：        * 封装POST请求消息的请求参数的    * 字符串格式：        POST /login.html    HTTP/1.1        Host: localhost        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2        Accept-Encoding: gzip, deflate        Referer: http://localhost/login.html        Connection: keep-alive        Upgrade-Insecure-Requests: 1        username=zhangsan    * 响应消息数据格式</code></pre><h2 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h2><pre><code>1. request对象和response对象的原理    1. request和response对象是由服务器创建的。我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息2. request对象继承体系结构：        ServletRequest        --    接口        |    继承    HttpServletRequest    -- 接口        |    实现    org.apache.catalina.connector.RequestFacade 类(tomcat)3. request功能：    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式 ：GET                    * String getMethod()                  2. (*)获取虚拟目录：/day14                    * String getContextPath()                3. 获取Servlet路径: /demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI():        /day14/demo1                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国                    * URI：统一资源标识符 : /day14/demo1                    共和国                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机的IP地址：                    * String getRemoteAddr()        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头的名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称        3. 获取请求体数据:            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据</code></pre><p>​<br>​        2. 其他功能：<br>​            1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数<br>​                1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123<br>​                2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game<br>​                3. Enumeration<String> getParameterNames():获取所有请求的参数名称<br>​                4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合<br>​<br>                * 中文乱码问题：<br>                    * get方式：tomcat 8 已经将get方式乱码问题解决了<br>                    Tomcat7<br>                        第一种情况：处理get方式引起的中文乱码<br>                        使用String的构造方法解决中文乱码：new String（字节数组，编码格                        式）；<br>     代码：String newvalue = new String(value.getBytes(“ISO8859-1”),”utf-8”);</p><pre><code>通过配置Tomcat来解决GET请求参数的乱码问题，可以在server.xml文件中的Connector节点下添加的属性是（  ） useBodyEncodingForURI = &quot;true&quot;                     第二种情况：处理post方式引起的中文乱码                     post提交，会把参数提交到request对象的缓冲区中，缓冲区默认编码是                        ISO8859-1不支持中文                     处理方法：把request缓冲区的编码给设置成支持中文的码表格式。                     request.setCharacterEncoding(&quot;utf-8&quot;);                * post方式：会乱码                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre><p>​<br>​            2. 请求转发：一种在服务器内部的资源跳转方式<br>​                1. 步骤：<br>​                    1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)<br>​                    2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)<br>​<br>                2. 特点：<br>                    1. 浏览器地址栏路径不发生变化<br>                    2. 只能转发到当前服务器内部资源中。<br>                    3. 转发是一次请求</p><pre><code>3. 共享数据：    * 域对象：一个有作用范围的对象，可以在范围内共享数据    * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据    * 方法：        1. void setAttribute(String name,Object obj):存储数据        2. Object getAttitude(String name):通过键获取值        3. void removeAttribute(String name):通过键移除键值对4. 获取ServletContext：    * ServletContext getServletContext()</code></pre><h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><pre><code>* 用户登录案例需求：    1.编写login.html登录页面        username &amp; password 两个输入框    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表    3.使用JdbcTemplate技术封装JDBC    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误* 分析* 开发步骤    1. 创建项目，导入html页面，配置文件，jar包    2. 创建数据库环境        CREATE DATABASE day14;        USE day14;        CREATE TABLE USER(            id INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(32) UNIQUE NOT NULL,            PASSWORD VARCHAR(32) NOT NULL        );    3. 创建包cn.itcast.domain,创建类User        package cn.itcast.domain;        /**         * 用户的实体类         */        public class User {            private int id;            private String username;            private String password;</code></pre><p>​<br>​                public int getId() {<br>​                    return id;<br>​                }<br>​<br>                public void setId(int id) {<br>                    this.id = id;<br>                }</p><pre><code>        public String getUsername() {            return username;        }        public void setUsername(String username) {            this.username = username;        }        public String getPassword() {            return password;        }        public void setPassword(String password) {            this.password = password;        }        @Override        public String toString() {            return &quot;User{&quot; +                    &quot;id=&quot; + id +                    &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; +                    &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +                    &apos;}&apos;;        }    }4. 创建包cn.itcast.util,编写工具类JDBCUtils    package cn.itcast.util;    import com.alibaba.druid.pool.DruidDataSourceFactory;    import javax.sql.DataSource;    import javax.xml.crypto.Data;    import java.io.IOException;    import java.io.InputStream;    import java.sql.Connection;    import java.sql.SQLException;    import java.util.Properties;    /**     * JDBC工具类 使用Durid连接池     */    public class JDBCUtils {        private static DataSource ds ;        static {            try {                //1.加载配置文件                Properties pro = new Properties();                //使用ClassLoader加载配置文件，获取字节输入流                InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);                pro.load(is);                //2.初始化连接池对象                ds = DruidDataSourceFactory.createDataSource(pro);            } catch (IOException e) {                e.printStackTrace();            } catch (Exception e) {                e.printStackTrace();            }        }        /**         * 获取连接池对象         */        public static DataSource getDataSource(){            return ds;        }</code></pre><p>​<br>​                /**<br>​                 * 获取连接Connection对象<br>​                 */<br>​                public static Connection getConnection() throws SQLException {<br>​                    return  ds.getConnection();<br>​                }<br>​            }<br>​        5. 创建包cn.itcast.dao,创建类UserDao,提供login方法<br>​<br>            package cn.itcast.dao;</p><pre><code>import cn.itcast.domain.User;import cn.itcast.util.JDBCUtils;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * 操作数据库中User表的类 */public class UserDao {    //声明JDBCTemplate对象共用    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());    /**     * 登录方法     * @param loginUser 只有用户名和密码     * @return user包含用户全部数据,没有查询到，返回null     */    public User login(User loginUser){        try {            //1.编写sql            String sql = &quot;select * from user where username = ? and password = ?&quot;;            //2.调用query方法            User user = template.queryForObject(sql,                    new BeanPropertyRowMapper&lt;User&gt;(User.class),                    loginUser.getUsername(), loginUser.getPassword());</code></pre><p>​<br>​                        return user;<br>​                    } catch (DataAccessException e) {<br>​                        e.printStackTrace();//记录日志<br>​                        return null;<br>​                    }<br>​                }<br>​            }<br>​<br>        6. 编写cn.itcast.web.servlet.LoginServlet类<br>            package cn.itcast.web.servlet;</p><pre><code>import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;</code></pre><p>​<br>​            @WebServlet(“/loginServlet”)<br>​            public class LoginServlet extends HttpServlet {</p><p>​<br>​                @Override<br>​                protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>​                    //1.设置编码<br>​                    req.setCharacterEncoding(“utf-8”);<br>​                    //2.获取请求参数<br>​                    String username = req.getParameter(“username”);<br>​                    String password = req.getParameter(“password”);<br>​                    //3.封装user对象<br>​                    User loginUser = new User();<br>​                    loginUser.setUsername(username);<br>​                    loginUser.setPassword(password);<br>​<br>                    //4.调用UserDao的login方法<br>                    UserDao dao = new UserDao();<br>                    User user = dao.login(loginUser);</p><pre><code>            //5.判断user            if(user == null){                //登录失败                req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);            }else{                //登录成功                //存储数据                req.setAttribute(&quot;user&quot;,user);                //转发                req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);            }        }        @Override        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {            this.doGet(req,resp);        }    }7. 编写FailServlet和SuccessServlet类    @WebServlet(&quot;/successServlet&quot;)    public class SuccessServlet extends HttpServlet {        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            //获取request域中共享的user对象            User user = (User) request.getAttribute(&quot;user&quot;);            if(user != null){                //给页面写一句话                //设置编码                response.setContentType(&quot;text/html;charset=utf-8&quot;);                //输出                response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;);            }</code></pre><p>​<br>​                }        </p><pre><code>    @WebServlet(&quot;/failServlet&quot;)    public class FailServlet extends HttpServlet {        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            //给页面写一句话            //设置编码            response.setContentType(&quot;text/html;charset=utf-8&quot;);            //输出            response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);        }        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            this.doPost(request,response);        }    }8. login.html中form表单的action路径的写法    * 虚拟目录+Servlet的资源路径9. BeanUtils工具类，简化数据封装    * 用于封装JavaBean的    1. JavaBean：标准的Java类        1. 要求：            1. 类必须被public修饰            2. 必须提供空参的构造器            3. 成员变量必须使用private修饰            4. 提供公共setter和getter方法        2. 功能：封装数据    2. 概念：        成员变量：        属性：setter和getter方法截取后的产物            例如：getUsername() --&gt; Username--&gt; username    3. 方法：        1. setProperty()        2. getProperty()        3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容：&quot;&gt;&lt;a href=&quot;#今日内容：&quot; class=&quot;headerlink&quot; title=&quot;今日内容：&quot;&gt;&lt;/a&gt;今日内容：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. Servlet
2. HTTP协议
3. Request&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat&amp;Servlet笔记</title>
    <link href="http://yoursite.com/2020/03/31/Tomcat&amp;Servlet%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/Tomcat&amp;Servlet笔记/</id>
    <published>2020-03-30T23:58:55.277Z</published>
    <updated>2020-03-31T00:06:19.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><a id="more"></a><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人        * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称        * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;* 执行原理：    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法* Servlet中的生命周期方法：    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target({ElementType.TYPE})            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet {                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                String[] value() default {};//代表urlPatterns()属性配置                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                WebInitParam[] initParams() default {};                boolean asyncSupported() default false;                String smallIcon() default &quot;&quot;;                String largeIcon() default &quot;&quot;;                String description() default &quot;&quot;;                String displayName() default &quot;&quot;;            }</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. web相关概念回顾
2. web服务器软件：Tomcat
3. Servlet入门学习&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xml笔记</title>
    <link href="http://yoursite.com/2020/03/31/xml%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/xml笔记/</id>
    <published>2020-03-30T23:58:42.555Z</published>
    <updated>2020-03-31T02:29:16.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. XML    1. 概念    2. 语法    3. 解析</code></pre><a id="more"></a><h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><pre><code>1. 概念：Extensible Markup Language 可扩展标记语言    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;    * 功能        * 存储数据            1. 配置文件            2. 在网络中传输    * xml与html的区别        1. xml标签都是自定义的，html标签是预定义。        2. xml的语法严格，html语法松散        3. xml是存储数据的，html是展示数据    * w3c:万维网联盟2. 语法：    * 基本语法：        1. xml文档的后缀名 .xml        2. xml第一行必须定义为文档声明        3. xml文档中有且仅有一个根标签        4. 属性值必须使用引号(单双都可)引起来        5. 标签必须正确关闭        6. xml标签名称区分大小写    * 快速入门：        &lt;?xml version=&apos;1.0&apos; ?&gt;        &lt;users&gt;            &lt;user id=&apos;1&apos;&gt;                &lt;name&gt;zhangsan&lt;/name&gt;                &lt;age&gt;23&lt;/age&gt;                &lt;gender&gt;male&lt;/gender&gt;                &lt;br/&gt;            &lt;/user&gt;            &lt;user id=&apos;2&apos;&gt;                &lt;name&gt;lisi&lt;/name&gt;                &lt;age&gt;24&lt;/age&gt;                &lt;gender&gt;female&lt;/gender&gt;            &lt;/user&gt;        &lt;/users&gt;    * 组成部分：        1. 文档声明            1. 格式：&lt;?xml 属性列表 ?&gt;            2. 属性列表：                * version：版本号，必须的属性                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1                * standalone：是否独立                    * 取值：                        * yes：不依赖其他文件                        * no：依赖其他文件        2. 指令(了解)：结合css的            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;        3. 标签：标签名称自定义的            * 规则：                * 名称可以包含字母、数字以及其他的字符                 * 名称不能以数字或者标点符号开始                 * 名称不能以字母 xml（或者 XML、Xml 等等）开始                 * 名称不能包含空格         4. 属性：            id属性值唯一        5. 文本：            * CDATA区：在该区域中的数据会被原样展示                * 格式：  &lt;![CDATA[ 数据 ]]&gt;</code></pre><p>​<br>​        * 约束：规定xml文档的书写规则<br>​            * 作为框架的使用者(程序员)：<br>​                1. 能够在xml中引入约束文档<br>​                2. 能够简单的读懂约束文档<br>​<br>            * 分类：<br>                1. DTD:一种简单的约束技术<br>                2. Schema:一种复杂的约束技术</p><pre><code>* DTD：    * 引入dtd文档到xml文档中        * 内部dtd：将约束规则定义在xml文档中        * 外部dtd：将约束的规则定义在外部的dtd文件中            * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;            * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;* Schema:    * 引入：        1.填写xml文档的根元素        2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;        4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot;     &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns=&quot;http://www.itcast.cn/xml&quot;        xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;</code></pre><p>​    </p><pre><code>3. 解析：操作xml文档，将文档中的数据读取到内存中    * 操作xml文档        1. 解析(读取)：将文档中的数据读取到内存中        2. 写入：将内存中的数据保存到xml文档中。持久化的存储    * 解析xml的方式：        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树            * 优点：操作方便，可以对文档进行CRUD的所有操作            * 缺点：占内存        2. SAX：逐行读取，基于事件驱动的。            * 优点：不占内存。            * 缺点：只能读取，不能增删改</code></pre><p>​<br>​        * xml常见的解析器：<br>​            1. JAXP：sun公司提供的解析器，支持dom和sax两种思想<br>​            2. DOM4J：一款非常优秀的解析器<br>​            3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<br>​            4. PULL：Android操作系统内置的解析器，sax方式的。</p><pre><code>* Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。    * 快速入门：        * 步骤：            1. 导入jar包            2. 获取Document对象            3. 获取对应的标签Element对象            4. 获取数据    * 代码：         //2.1获取student.xml的path        String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();        //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document        Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);        //3.获取元素对象 Element        Elements elements = document.getElementsByTag(&quot;name&quot;);        System.out.println(elements.size());        //3.1获取第一个name的Element对象        Element element = elements.get(0);        //3.2获取数据        String name = element.text();        System.out.println(name);* 对象的使用：    1. Jsoup：工具类，可以解析html或xml文档，返回Document        * parse：解析html或xml文档，返回Document            * parse​(File in, String charsetName)：解析xml或html文件的。            * parse​(String html)：解析xml或html字符串            * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象    2. Document：文档对象。代表内存中的dom树        * 获取Element对象            * getElementById​(String id)：根据id属性值获取唯一的element对象            * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合            * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合            * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合    3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用    4. Element：元素对象        1. 获取子元素对象            * getElementById​(String id)：根据id属性值获取唯一的element对象            * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合            * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合            * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合        2. 获取属性值            * String attr(String key)：根据属性名称获取属性值        3. 获取文本内容            * String text():获取文本内容            * String html():获取标签体的所有内容(包括字标签的字符串内容)    5. Node：节点对象        * 是Document和Element的父类</code></pre><p>​<br>​        * 快捷查询方式：<br>​            1. selector:选择器<br>​                * 使用的方法：Elements    select​(String cssQuery)<br>​                    * 语法：参考Selector类中定义的语法<br>​            2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<br>​                * 使用Jsoup的Xpath需要额外导入jar包。<br>​                * 查询w3cshool参考手册，使用xpath的语法完成查询<br>​                * 代码：<br>​                    //1.获取student.xml的path<br>​                    String path = JsoupDemo6.class.getClassLoader().getResource(“student.xml”).getPath();<br>​                    //2.获取Document对象<br>​                    Document document = Jsoup.parse(new File(path), “utf-8”);<br>​<br>                    //3.根据document对象，创建JXDocument对象<br>                    JXDocument jxDocument = new JXDocument(document);</p><pre><code>//4.结合xpath语法查询//4.1查询所有student标签List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);for (JXNode jxNode : jxNodes) {    System.out.println(jxNode);}System.out.println(&quot;--------------------&quot;);//4.2查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);for (JXNode jxNode : jxNodes2) {    System.out.println(jxNode);}System.out.println(&quot;--------------------&quot;);//4.3查询student标签下带有id属性的name标签List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);for (JXNode jxNode : jxNodes3) {    System.out.println(jxNode);}System.out.println(&quot;--------------------&quot;);//4.4查询student标签下带有id属性的name标签 并且id属性值为itcastList&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);for (JXNode jxNode : jxNodes4) {    System.out.println(jxNode);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. XML
    1. 概念
    2. 语法
    3. 解析&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript高级笔记</title>
    <link href="http://yoursite.com/2020/03/31/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/JavaScript高级笔记/</id>
    <published>2020-03-30T23:58:29.660Z</published>
    <updated>2020-03-31T02:37:08.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. JavaScript：    1. ECMAScript：    2. BOM：    3. DOM：        1. 事件</code></pre><a id="more"></a><h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容* 获取页面标签(元素)对象：Element    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象* 操作Element对象：    1. 修改属性值：        1. 明确获取的对象是哪一个？        2. 查看API文档，找其中有哪些属性可以设置    2. 修改标签体内容：        * 属性：innerHTML        1. 获取元素对象        2. 使用innerHTML属性修改标签体内容</code></pre><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><pre><code>* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。    * 造句：  xxx被xxx,我就xxx        * 我方水晶被摧毁后，我就责备对友。        * 敌方水晶被摧毁后，我就夸奖自己。* 如何绑定事件    1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码        1. 事件：onclick--- 单击事件    2. 通过js获取元素对象，指定事件属性，设置一个函数    * 代码：        &lt;body&gt;            &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt;            &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt;            &lt;script&gt;                function fun(){                    alert(&apos;我被点了&apos;);                    alert(&apos;我又被点了&apos;);                }                function fun2(){                    alert(&apos;咋老点我？&apos;);                }                //1.获取light2对象                var light2 = document.getElementById(&quot;light2&quot;);                //2.绑定事件                light2.onclick = fun2;</code></pre><p>​<br>​                </script><br>​            </body><br>​<br>    * 案例1：电灯开关<br>        <!DOCTYPE html><br>        <html lang="en"><br>        <head><br>            <meta charset="UTF-8"><br>            <title>电灯开关</title></p><pre><code>&lt;/head&gt;&lt;body&gt;&lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;&lt;script&gt;    /*        分析：            1.获取图片对象            2.绑定单击事件            3.每次点击切换图片                * 规则：                    * 如果灯是开的 on,切换图片为 off                    * 如果灯是关的 off,切换图片为 on                * 使用标记flag来完成     */    //1.获取图片对象    var light = document.getElementById(&quot;light&quot;);    var flag = false;//代表灯是灭的。 off图片    //2.绑定单击事件    light.onclick = function(){        if(flag){//判断如果灯是开的，则灭掉            light.src = &quot;img/off.gif&quot;;            flag = false;        }else{            //如果灯是灭的，则打开            light.src = &quot;img/on.gif&quot;;            flag = true;        }</code></pre><p>​<br>​            }<br>​<br>        </script><br>        </body><br>        </html></p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><pre><code>1. 概念：Browser Object Model 浏览器对象模型    * 将浏览器的各个组成部分封装成对象。2. 组成：    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象3. Window：窗口对象    1. 创建    2. 方法         1. 与弹出框有关的方法：            alert()    显示带有一段消息和一个确认按钮的警告框。            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。                * 如果用户点击确定按钮，则方法返回true                * 如果用户点击取消按钮，则方法返回false            prompt()    显示可提示用户输入的对话框。                * 返回值：获取用户输入的值         2. 与打开关闭有关的方法：            close()    关闭浏览器窗口。                * 谁调用我 ，我关谁            open()    打开一个新的浏览器窗口                * 返回新的Window对象         3. 与定时器有关的方式            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由 setInterval() 设置的 timeout。    3. 属性：        1. 获取其他BOM对象：            history            location            Navigator            Screen:        2. 获取DOM对象            document    4. 特点        * Window对象不需要创建可以直接使用 window使用。 window.方法名();        * window引用可以省略。  方法名();4. Location：地址栏对象    1. 创建(获取)：        1. window.location        2. location    2. 方法：        * reload()    重新加载当前文档。刷新    3. 属性        * href    设置或返回完整的 URL。5. History：历史记录对象    1. 创建(获取)：        1. window.history        2. history    2. 方法：        * back()    加载 history 列表中的前一个 URL。        * forward()    加载 history 列表中的下一个 URL。        * go(参数)    加载 history 列表中的某个具体页面。            * 参数：                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性：        * length    返回当前窗口历史列表中的 URL 数量。</code></pre><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><pre><code>* 概念： Document Object Model 文档对象模型    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作* W3C DOM 标准被分为 3 个不同的部分：    * 核心 DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment:注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对 XML 文档的标准模型    * HTML DOM - 针对 HTML 文档的标准模型* 核心DOM模型：    * Document：文档对象        1. 创建(获取)：在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法：            1. 获取Element对象：                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组            2. 创建其他DOM对象：                createAttribute(name)                createComment()                createElement()                createTextNode()        3. 属性    * Element：元素对象        1. 获取/创建：通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树：                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()    ：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性：            * parentNode 返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象的属性    3. 控制元素样式        1. 使用元素的style属性来设置            如：                 //修改样式方式1                div1.style.border = &quot;1px solid red&quot;;                div1.style.width = &quot;200px&quot;;                //font-size--&gt; fontSize                div1.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</code></pre><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。        * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了    * 事件源：组件。如： 按钮 文本输入框...    * 监听器：代码。    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。* 常见的事件：    1. 点击事件：        1. onclick：单击事件        2. ondblclick：双击事件    2. 焦点事件        1. onblur：失去焦点        2. onfocus:元素获得焦点。    3. 加载事件：        1. onload：一张页面或一幅图像完成加载。    4. 鼠标事件：        1. onmousedown    鼠标按钮被按下。        2. onmouseup    鼠标按键被松开。        3. onmousemove    鼠标被移动。        4. onmouseover    鼠标移到某元素之上。        5. onmouseout    鼠标从某元素移开。</code></pre><p>​<br>​        5. 键盘事件：<br>​            1. onkeydown    某个键盘按键被按下。<br>​            2. onkeyup        某个键盘按键被松开。<br>​            3. onkeypress    某个键盘按键被按下并松开。<br>​<br>        6. 选择和改变<br>            1. onchange    域的内容被改变。<br>            2. onselect    文本被选中。</p><pre><code>7. 表单事件：    1. onsubmit    确认按钮被点击。    2. onreset    重置按钮被点击。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容：&quot;&gt;&lt;a href=&quot;#今日内容：&quot; class=&quot;headerlink&quot; title=&quot;今日内容：&quot;&gt;&lt;/a&gt;今日内容：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. JavaScript：
    1. ECMAScript：
    2. BOM：
    3. DOM：
        1. 事件&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript基础笔记</title>
    <link href="http://yoursite.com/2020/03/31/JavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/JavaScript基础笔记/</id>
    <published>2020-03-30T23:58:17.667Z</published>
    <updated>2020-03-31T02:29:35.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JavaScript基础</code></pre><a id="more"></a><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><pre><code>* 概念：    一门客户端脚本语言    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了* 功能：    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。* JavaScript发展史：    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)* ECMAScript：客户端脚本语言的标准    1. 基本语法：        1. 与html结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：//注释内容            2. 多行注释：/*注释内容*/        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &apos;abc&apos;                3. boolean: true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined            2. 引用数据类型：对象        4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言。                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。            * 语法：                * var 变量名 = 初始化值;            * typeof运算符：获取变量的类型。                * 注：null运算后得到的是object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++，-- ， +(正号)                  * ++ --: 自增(自减)                    * ++(--) 在前，先自增(自减)，再运算                    * ++(--) 在后，先运算，再自增(自减)                * +(-)：正负号                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换                    * 其他类型转number：                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）                        * boolean转number：true转为1，false转为0            2. 算数运算符                + - * / % ...            3. 赋值运算符                = += -+....            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                  1. 类型相同：直接比较                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。                  2. 类型不同：先进行类型转换，再比较                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean：                   1. number：0或NaN为假，其他为真                   2. string：除了空字符串(&quot;&quot;)，其他都是true                   3. null&amp;undefined:都是false                   4. 对象：所有对象都为true            6. 三元运算符                ? : 表达式                var a = 3;                var b = 4;                var c = a &gt; b ? 1:0;                * 语法：                    * 表达式? 值1:值2;                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；        6. 流程控制语句：            1. if...else...            2. switch:                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)                    * switch(变量):                        case 值:                * 在JS中,switch语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)            2. 变量的定义使用var关键字，也可以不使用                * 用： 定义的变量是局部变量                * 不用：定义的变量是全局变量(不建议)        8. 练习：99乘法表        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;99乘法表&lt;/title&gt;            &lt;style&gt;                td{                    border: 1px solid;                }            &lt;/style&gt;            &lt;script&gt;                document.write(&quot;&lt;table  align=&apos;center&apos;&gt;&quot;);</code></pre><p>​<br>​                    //1.完成基本的for循环嵌套，展示乘法表<br>​                    for (var i = 1; i &lt;= 9 ; i++) {<br>​                        document.write(“<tr>“);<br>​                        for (var j = 1; j &lt;=i ; j++) {<br>​                            document.write(“<td>“);<br>​<br>                            //输出  1 * 1 = 1<br>                            document.write(i + “ * “ + j + “ = “ + ( i*j) +”&nbsp;&nbsp;&nbsp;”);</p><pre><code>                        document.write(&quot;&lt;/td&gt;&quot;);                    }                    /*//输出换行                    document.write(&quot;&lt;br&gt;&quot;);*/                    document.write(&quot;&lt;/tr&gt;&quot;);                }                //2.完成表格嵌套                document.write(&quot;&lt;/table&gt;&quot;);            &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 基本对象：        1. Function：函数(方法)对象            1. 创建：                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧                2.                     function 方法名称(形式参数列表){                        方法体                    }                3.                    var 方法名 = function(形式参数列表){                        方法体                   }            2. 方法：            3. 属性：                length:代表形参的个数            4. 特点：                1. 方法定义是，形参的类型不用写,返回值类型也不写。                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数            5. 调用：                方法名称(实际参数列表);        2. Array:数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数):将数组中的元素按照指定的分隔符拼接为字符串                push()    向数组的末尾添加一个或更多元素，并返回新的长度。            3. 属性                length:数组的长度            4. 特点：                1. JS中，数组元素的类型可变的。                2. JS中，数组长度可变的。        3. Boolean        4. Date：日期对象            1. 创建：                var date = new Date();            2. 方法：                toLocaleString()：返回当前date对象对应的时间本地字符串格式                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差        5. Math：数学对象            1. 创建：                * 特点：Math对象不用创建，直接使用。  Math.方法名();            2. 方法：                random():返回 0 ~ 1 之间的随机数。 含0不含1                ceil(x)：对数进行上舍入。                floor(x)：对数进行下舍入。                round(x)：把数四舍五入为最接近的整数。            3. 属性：                PI        6. Number        7. String        8. RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如： [a] [ab] [a-zA-Z0-9_]                    * 特殊符号代表特殊含义的单个字符:                        \d:单个数字字符 [0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?：表示出现0次或1次                    *：表示出现0次或多次                    +：出现1次或多次                    {m,n}:表示 m&lt;= 数量 &lt;= n                        * m如果缺省： {,n}:最多n次                        * n如果缺省：{m,} 最少m次                3. 开始结束符号                    * ^:开始                    * $:结束            2. 正则对象：                1. 创建                    1. var reg = new RegExp(&quot;正则表达式&quot;);                    2. var reg = /正则表达式/;                2. 方法                        1. test(参数):验证指定的字符串是否符合正则定义的规范            9. Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码,编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number                isNaN():判断一个值是否是NaN                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。            3. URL编码               传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2* BOM* DOM</code></pre><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. JavaScript基础&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDBC连接池&amp;JDBCTemplate课堂笔记</title>
    <link href="http://yoursite.com/2020/03/31/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&amp;JDBCTemplate%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/JDBC连接池&amp;JDBCTemplate课堂笔记/</id>
    <published>2020-03-30T23:57:53.581Z</published>
    <updated>2020-03-31T00:05:30.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><a id="more"></a><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils {            //1.定义成员变量 DataSource            private static DataSource ds ;            static{                try {                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                } catch (IOException e) {                    e.printStackTrace();                } catch (Exception e) {                    e.printStackTrace();                }            }            /**             * 获取连接             */            public static Connection getConnection() throws SQLException {                return ds.getConnection();            }            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn){               /* if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }*/               close(null,stmt,conn);            }</code></pre><p>​<br>                public static void close(ResultSet rs , Statement stmt, Connection conn){</p><p>​<br>                    if(rs != null){<br>                        try {<br>                            rs.close();<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }</p><p>​<br>                    if(stmt != null){<br>                        try {<br>                            stmt.close();<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }</p><pre><code>        if(conn != null){            try {                conn.close();//归还连接            } catch (SQLException e) {                e.printStackTrace();            }        }    }    /**     * 获取连接池方法     */    public static DataSource getDataSource(){        return  ds;    }}</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 {                //Junit单元测试，可以让方法独立执行</code></pre><p>​<br>                    //1. 获取JDBCTemplate对象<br>                    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());<br>                    /**<br>                     * 1. 修改1号数据的 salary 为 10000<br>                     */<br>                    @Test<br>                    public void test1(){</p><pre><code>    //2. 定义sql    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;    //3. 执行sql    int count = template.update(sql);    System.out.println(count);}/** * 2. 添加一条记录 */@Testpublic void test2(){    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);    System.out.println(count);}/** * 3.删除刚才添加的记录 */@Testpublic void test3(){    String sql = &quot;delete from emp where id = ?&quot;;    int count = template.update(sql, 1015);    System.out.println(count);}/** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */@Testpublic void test4(){    String sql = &quot;select * from emp where id = ? or id = ?&quot;;    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);    System.out.println(map);    //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}}/** * 5. 查询所有记录，将其封装为List */@Testpublic void test5(){    String sql = &quot;select * from emp&quot;;    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);    for (Map&lt;String, Object&gt; stringObjectMap : list) {        System.out.println(stringObjectMap);    }}/** * 6. 查询所有记录，将其封装为Emp对象的List集合 */@Testpublic void test6(){    String sql = &quot;select * from emp&quot;;    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {        @Override        public Emp mapRow(ResultSet rs, int i) throws SQLException {            Emp emp = new Emp();            int id = rs.getInt(&quot;id&quot;);            String ename = rs.getString(&quot;ename&quot;);            int job_id = rs.getInt(&quot;job_id&quot;);            int mgr = rs.getInt(&quot;mgr&quot;);            Date joindate = rs.getDate(&quot;joindate&quot;);            double salary = rs.getDouble(&quot;salary&quot;);            double bonus = rs.getDouble(&quot;bonus&quot;);            int dept_id = rs.getInt(&quot;dept_id&quot;);            emp.setId(id);            emp.setEname(ename);            emp.setJob_id(job_id);            emp.setMgr(mgr);            emp.setJoindate(joindate);            emp.setSalary(salary);            emp.setBonus(bonus);            emp.setDept_id(dept_id);            return emp;        }    });</code></pre><p>​<br>                        for (Emp emp : list) {<br>                            System.out.println(emp);<br>                        }<br>                    }</p><pre><code>    /**     * 6. 查询所有记录，将其封装为Emp对象的List集合     */    @Test    public void test6_2(){        String sql = &quot;select * from emp&quot;;        List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));        for (Emp emp : list) {            System.out.println(emp);        }    }    /**     * 7. 查询总记录数     */    @Test    public void test7(){        String sql = &quot;select count(id) from emp&quot;;        Long total = template.queryForObject(sql, Long.class);        System.out.println(total);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 数据库连接池

2. Spring JDBC : JDBC Template&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDBC课堂笔记</title>
    <link href="http://yoursite.com/2020/03/31/JDBC%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/31/JDBC课堂笔记/</id>
    <published>2020-03-30T23:57:35.011Z</published>
    <updated>2020-03-31T00:05:21.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JDBC基本概念2. 快速入门3. 对JDBC中各个接口和类详解</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：<a id="more"></a></h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static {                        try {                            java.sql.DriverManager.registerDriver(new Driver());                        } catch (SQLException E) {                            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);                        }                    }                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try {                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0){                        System.out.println(&quot;添加成功！&quot;);                    }else{                        System.out.println(&quot;添加失败！&quot;);                    }                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } catch (SQLException e) {                    e.printStackTrace();                }finally {                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null){                        try {                            stmt.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                    if(conn != null){                        try {                            conn.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                }    4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next()){                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                }        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll(){}                3. 实现方法 select * from emp;    5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a            2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils {    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static{        //读取资源文件，获取值。        try {            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }</code></pre><p>​<br>        /**<br>         * 获取连接<br>         * @return 连接对象<br>         */<br>        public static Connection getConnection() throws SQLException {</p><pre><code>    return DriverManager.getConnection(url, user, password);}/** * 释放资源 * @param stmt * @param conn */public static void close(Statement stmt,Connection conn){    if( stmt != null){        try {            stmt.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if( conn != null){        try {            conn.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><p>​<br>        /**<br>         * 释放资源<br>         * @param stmt<br>         * @param conn<br>         */<br>        public static void close(ResultSet rs,Statement stmt, Connection conn){<br>            if( rs != null){<br>                try {<br>                    rs.close();<br>                } catch (SQLException e) {<br>                    e.printStackTrace();<br>                }<br>            }</p><pre><code>        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );            INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;);            INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;);        2. 代码实现：            public class JDBCDemo9 {                public static void main(String[] args) {                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag){                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    }else{                        System.out.println(&quot;用户名或密码错误！&quot;);                    }</code></pre><p>​<br>                    }</p><p>​<br>​<br>                    /<em>*<br>                     * 登录方法<br>                     */<br>                    public boolean login(String username ,String password){<br>                        if(username == null || password == null){<br>                            return false;<br>                        }<br>                        //连接数据库判断是否登录成功<br>                        Connection conn = null;<br>                        Statement stmt =  null;<br>                        ResultSet rs = null;<br>                        //1.获取连接<br>                        try {<br>                            conn =  JDBCUtils.getConnection();<br>                            //2.定义sql<br>                            String sql = “select * from user where username = ‘“+username+”‘ and password = ‘“+password+”‘ “;<br>                            //3.获取执行sql的对象<br>                            stmt = conn.createStatement();<br>                            //4.执行查询<br>                            rs = stmt.executeQuery(sql);<br>                            //5.判断<br>                           /</em> if(rs.next()){//如果有下一行，则返回true<br>                                return true;<br>                            }else{<br>                                return false;<br>                            }*/<br>                           return rs.next();//如果有下一行，则返回true</p><pre><code>} catch (SQLException e) {    e.printStackTrace();}finally {    JDBCUtils.close(rs,stmt,conn);}</code></pre><p>​<br>                        return false;<br>                    }<br>                }</p><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 {        public static void main(String[] args) {            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;            try {                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                pstmt2.executeUpdate();                //提交事务                conn.commit();            } catch (Exception e) {                //事务回滚                try {                    if(conn != null) {                        conn.rollback();                    }                } catch (SQLException e1) {                    e1.printStackTrace();                }                e.printStackTrace();            }finally {                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            }</code></pre><p>​<br>            }</p><pre><code>}</code></pre><p>​            </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. JDBC基本概念
2. 快速入门
3. 对JDBC中各个接口和类详解&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;JDBC：&quot;&gt;&lt;a href=&quot;#JDBC：&quot; class=&quot;headerlink&quot; title=&quot;JDBC：&quot;&gt;&lt;/a&gt;JDBC：
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>导数与微分</title>
    <link href="http://yoursite.com/2020/03/24/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/24/导数与微分/</id>
    <published>2020-03-24T02:05:01.863Z</published>
    <updated>2020-03-24T03:24:26.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导数与微分的理解"><a href="#导数与微分的理解" class="headerlink" title="导数与微分的理解"></a>导数与微分的理解</h2><p>[TOC]</p><h3 id="首先高数课本上导数的定义："><a href="#首先高数课本上导数的定义：" class="headerlink" title="首先高数课本上导数的定义："></a>首先高数课本上导数的定义：<a id="more"></a></h3><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200324/3LhVkBRIwBYy.png?imageslim" alt="mark"></p><h3 id="微分的定义："><a href="#微分的定义：" class="headerlink" title="微分的定义："></a>微分的定义：</h3><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200324/IzonWgSeNOtt.png?imageslim" alt="mark"></p><p>个人总觉得难懂，遇上上网寻找答案，找到知乎上一回答，对我很有启发。特此借鉴</p><p>其内容如下</p><h3 id="微积分发展的历史和数学思想，主要针对-这样的一元函数。"><a href="#微积分发展的历史和数学思想，主要针对-这样的一元函数。" class="headerlink" title="微积分发展的历史和数学思想，主要针对  这样的一元函数。"></a>微积分发展的历史和数学思想，主要针对 <img src="https://www.zhihu.com/equation?tex=y%3Df%28x%29" alt="[公式]"> 这样的一元函数。</h3><h4 id="1-牛顿、莱布尼兹开始的古典微积分"><a href="#1-牛顿、莱布尼兹开始的古典微积分" class="headerlink" title="1 牛顿、莱布尼兹开始的古典微积分"></a><strong>1 牛顿、莱布尼兹开始的古典微积分</strong></h4><p>牛顿和莱布尼兹各自独立发明了微积分，下面我采取莱布尼兹的微积分符号进行说明（要了解各种微积分符号，可以参看 <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25AF%25BC%25E6%2595%25B0">—-维基百科</a> ）。</p><h5 id="1-1-导数为什么出现？"><a href="#1-1-导数为什么出现？" class="headerlink" title="1.1 导数为什么出现？"></a><strong>1.1 导数为什么出现？</strong></h5><p>导数的出现不是牛顿和莱布尼兹发明的，之前数学家已经在对曲线的切线进行研究了，但是牛顿和莱布尼兹在解决曲面下面积的时候把导数的定义确定下来了。</p><p>曲线下的面积在微积分出现之前是一个很复杂的问题，微积分求解的主要思想是把曲线下的面积划分成了无数个矩形面积之和：</p><p><img src="https://pic3.zhimg.com/7a309c5ac7d603626f6fc252bd3176a6_b.png" alt="img"></p><p>直觉告诉我们，如果 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 越大，则这个近似越准确：</p><p><img src="https://pic1.zhimg.com/5396faefd2f3501c287903faf98600d0_b.png" alt="img"></p><p>无穷小量就在这里出现了，无穷小量是建立微积分的基础，莱布尼兹介绍微积分的论文就叫做《论深度隐藏的几何学及无穷小与无穷大的分析》。在当时的观点下，无穷小量到底是什么也是有争论的，当时有数学家打比喻：“无穷小量就好比山上的灰尘，去掉和增加都没有什么影响”，很显然有人认为这是真实存在的。</p><p>在具体计算曲面下面积，即我们现在所说的定积分的时候，必然会遇到导数的问题，所以很自然的开始了对导数的定义和讨论。</p><h5 id="1-2-导数的古典定义"><a href="#1-2-导数的古典定义" class="headerlink" title="1.2 导数的古典定义"></a><strong>1.2 导数的古典定义</strong></h5><p>在曲线上取两点，连接起来，就称为曲线的割线：</p><p><img src="https://pic3.zhimg.com/c628daac6d6219eadca61396aa853ebe_b.png" alt="img"></p><p>割线可以反应曲线的平均变化率，也就是说这一段大概总的趋势是上升还是下降，上升了多少，但是并不精确。</p><p><img src="https://pic2.zhimg.com/80/88c4a488ae041a39da5c1e4892c6a055_720w.png" alt="img"></p><p>有了切线之后我们进一步去定义导数：</p><p><img src="https://pic2.zhimg.com/3c7eb94341181775449815dddb9a6d51_b.png" alt="img"></p><p>从这张图得出导数的定义 <img src="https://www.zhihu.com/equation?tex=f%27%28x%29%3D%5Cfrac%7Bdy%7D%7Bdx%7D" alt="[公式]"> ，而 <img src="https://www.zhihu.com/equation?tex=dx" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=dy" alt="[公式]"> 被称为 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]"> 的微分，都为无穷小量，所以导数也被莱布尼兹称为微商（微分之商)。</p><h5 id="1-3-无穷小量导致的麻烦"><a href="#1-3-无穷小量导致的麻烦" class="headerlink" title="1.3 无穷小量导致的麻烦"></a><strong>1.3 无穷小量导致的麻烦</strong></h5><p>上一节的图实际上是有矛盾的：</p><p><img src="https://pic1.zhimg.com/61ecf4ae56111a5aece4888318c231fc_b.png" alt="img"></p><p>所以就切线的定义而言，微积分的基础就是不牢固的。</p><p>无穷小量的麻烦还远远不止这一些， <img src="https://www.zhihu.com/equation?tex=x%5E2" alt="[公式]"> 的导数是这样计算的：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++%5Cfrac%7Bd%7D%7Bdx%7D%28x%5E2%29+%26++%3D+%5Cfrac%7Bf%28x%2Bdx%29-f%28x%29%7D%7Bdx%7D+%5C%5C+%26++%3D+%5Cfrac%7B%28x%2Bdx%29%5E2-x%5E2%7D%7Bdx%7D+%5C%5C+%26++%3D+%5Cfrac%7Bx%5E2%2B2xdx%2Bdx%5E2-x%5E2%7D%7Bdx%7D+%5C%5C+%26++%3D+%5Cfrac%7B2xdx%2Bdx%5E2%7D%7Bdx%7D+%5C%5C+%26++%3D+2x%2Bdx+%5C%5C+%26++%3D+2x+%5Cend%7Balign%7D" alt="[公式]"></p><p>仔细看看运算过程， <img src="https://www.zhihu.com/equation?tex=dx" alt="[公式]"> 先是在约分中被约掉，然后又在加法中被忽略，就是说，先被当作了非0的量，又被当作了0，这就是大主教贝克莱（就是在高中政治书被嘲笑的唯心主义的代表）所攻击的像幽灵一样的数，一会是0一会又不是0。</p><p>无穷小量和无穷小量相除为什么可以得到不一样的值？难道不应该都是1？</p><p>无穷小量还违反了 <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2598%25BF%25E5%259F%25BA%25E7%25B1%25B3%25E5%25BE%25B7%25E5%2585%25AC%25E7%2590%2586">阿基米德公理</a> ，这个才是更严重的缺陷，康托尔证明过，如果阿基米德公理被违背的话会出大问题。</p><p>一边是看起来没有错的微积分，一边是有严重缺陷的无穷小量，这就是第二次数学危机。数学的严格性受到了挑战，“对于数学，严格性不是一切，但是没有了严格性就没有了一切”。</p><h5 id="1-4-对于古典微积分的总结"><a href="#1-4-对于古典微积分的总结" class="headerlink" title="1.4 对于古典微积分的总结"></a><strong>1.4 对于古典微积分的总结</strong></h5><ul><li>切线：通过无穷小量定义了切线</li><li>导数：导数就是切线的斜率</li><li>微分：微分是微小的增量，即无穷小量</li></ul><h4 id="2-基于极限重建微积分"><a href="#2-基于极限重建微积分" class="headerlink" title="2 基于极限重建微积分"></a><strong>2 基于极限重建微积分</strong></h4><p>莱布尼兹、欧拉等都认识到了无穷小量导致的麻烦，一直拼命想要修补，但是这个问题要等到200年后，19世纪极限概念的清晰之后才得到解决。</p><p>解决办法是，完全摈弃无穷小量，基于极限的概念，重新建立了微积分。</p><h5 id="2-1-极限"><a href="#2-1-极限" class="headerlink" title="2.1 极限"></a><strong>2.1 极限</strong></h5><p>现在都是用 <img src="https://www.zhihu.com/equation?tex=%5Cepsilon+-%5Cdelta+" alt="[公式]"> 语言来描述极限：</p><p><img src="https://pic4.zhimg.com/0afe3d0aafd33781261c35f90f085a07_b.png" alt="img"></p><p>可以看到，极限的描述并没有用到什么无穷小量。</p><h5 id="2-2-导数的极限定义"><a href="#2-2-导数的极限定义" class="headerlink" title="2.2 导数的极限定义"></a><strong>2.2 导数的极限定义</strong></h5><blockquote><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++%5Cdisplaystyle+f%27%28x_0%29%26+%3D%5Cfrac%7Bdy%7D%7Bdx%7D%5C%5C+%26+%3D%5Clim+_%7B%5CDelta+x+%5Cto+0%7D%5Cfrac%7B%5CDelta+y%7D%7B%5CDelta+x%7D%5C%5C+%26+%3D%5Clim+_%7B%5CDelta+x+%5Cto+0%7D%5Cfrac%7Bf%28x_0%2B%5CDelta+x%29-f%28x_0%29%7D%7B%5CDelta+x%7D+%5Cend%7Balign%7D" alt="[公式]">维基百科</p></blockquote><p>用极限重新严格定义了导数，已经脱离了微商的概念，此时，导数应该被看成一个整体。</p><p>不过我们仍然可以去定义什么是微分，说到这里，真是有点剧情反转，原来是先定义了微分再有的导数，现在却是先定义了导数再有的微分。</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200324/h2LpukCxGK4Y.png?imageslim" alt="mark"></p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta+y%3Df%27%28x_0%29%5CDelta+x%2Ba%5CDelta+x" alt="[公式]"> 可以得出， <img src="https://www.zhihu.com/equation?tex=%5CDelta+y" alt="[公式]"> 由两部分组成，通过图来观察一下几何意义：</p><p><img src="https://pic3.zhimg.com/38aa32221424bf6a6c924080ac9ecba6_b.png" alt="img">![img]</p><p><img src="https://www.zhihu.com/equation?tex=dy%3Df%27%28x%29%5CDelta+x" alt="[公式]"> ，这是 <img src="https://www.zhihu.com/equation?tex=dy" alt="[公式]"> 的定义。</p><p>我们令 <img src="https://www.zhihu.com/equation?tex=y%3Dx%5Cimplies+dy%3D1%5CDelta+x%5Cimplies+dx%3D%5CDelta+x" alt="[公式]"> ，这个 <img src="https://www.zhihu.com/equation?tex=dx" alt="[公式]"> 的定义。</p><p>最后我们可以得到 <img src="https://www.zhihu.com/equation?tex=dy%3Df%27%28x%29dx%5Cimplies+%5Cfrac%7Bdy%7D%7Bdx%7D%3Df%27%28x%29" alt="[公式]"> ：</p><p><img src="https://pic1.zhimg.com/96748e87494305f0274d0921a7d17484_b.png" alt="img"></p><h5 id="2-3-对于极限微积分的总结"><a href="#2-3-对于极限微积分的总结" class="headerlink" title="2.3 对于极限微积分的总结"></a><strong>2.3 对于极限微积分的总结</strong></h5><ul><li>导数：被定义为一个极限，其意义就是变化率</li><li>微分：是一个线性函数，其意义就是变化的具体数值</li><li>切线：有了导数之后就可以被确定下来了</li></ul><h4 id="3-疑问的解答"><a href="#3-疑问的解答" class="headerlink" title="3 疑问的解答"></a><strong>3 疑问的解答</strong></h4><p>微积分实际上被发明了两次，古典微积分和极限微积分可以说是两个东西。我们再来比较一下古典微积分和极限微积分。</p><h5 id="3-1-古典微积分与极限微积分的对比"><a href="#3-1-古典微积分与极限微积分的对比" class="headerlink" title="3.1 古典微积分与极限微积分的对比"></a><strong>3.1 古典微积分与极限微积分的对比</strong></h5><ul><li>古典微积分是先定义微分再定义导数，极限微积分是先定义导数再定义微分。</li><li>古典微积分的导数是基于无穷小量定义的，极限微积分的导数是基于极限定义的。</li><li>古典微积分的微分是无穷小量，极限微积分的微分是一个线性函数。</li><li>古典微积分的定积分是求无穷小矩形面积的和，极限微积分的定积分是求黎曼和。</li><li>古典微积分的切线是可以画出来的，极限微积分的切线是算出来的。</li><li>古典微积分的建立过程很直观，极限微积分的建立过程更抽象。</li></ul><p>古典微积分最大的好处就是很直观，不过也是因为太直观了，所以我们一直都无法忘记它带来的印象，也对我们理解极限微积分造成了障碍。也让我们在实际应用中造成了错误的理解。</p><h5 id="3-2-疑问的解答"><a href="#3-2-疑问的解答" class="headerlink" title="3.2 疑问的解答"></a><strong>3.2 疑问的解答</strong></h5><p>之前的疑惑主要是由于古典微积分带来的。</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7Bdy%7D%7Bdx%7D%3D%5Cfrac%7Bdy%7D%7Bdu%7D%5Cfrac%7Bdu%7D%7Bdx%7D" alt="[公式]"> ，在古典微积分中可以理解为消去，但是在极限微积分中我们应该认识到，这两个 <img src="https://www.zhihu.com/equation?tex=du" alt="[公式]"> 实际上是不同的函数。</li><li><img src="https://www.zhihu.com/equation?tex=%5Cint+_+a%5E+b+%5Cfrac%7Bdy%7D%7Bdx%7Ddx" alt="[公式]"> 古典微积分中， <img src="https://www.zhihu.com/equation?tex=dx" alt="[公式]"> 确实表明是无穷多个矩形的底边，消去也是合理的，而极限微积分中， <img src="https://www.zhihu.com/equation?tex=%5Cint+_+a%5E+b+dx" alt="[公式]"> 是求黎曼和，我们可以把 <img src="https://www.zhihu.com/equation?tex=%5Cint+_+a%5E+b" alt="[公式]"> 当作左括号， <img src="https://www.zhihu.com/equation?tex=dx" alt="[公式]"> 当作右括号，就好比 <img src="https://www.zhihu.com/equation?tex=%282%2B6%29%3D8" alt="[公式]"> ，计算完毕之后，括号自然就消失了。</li><li><img src="https://www.zhihu.com/equation?tex=d%28uv%29%3D%28u%2Bdu%29%28v%2Bdv%29-uv%3Dudv%2Bvdu%2Bdudv" alt="[公式]"> 在古典微积分中这么计算没有错误，只是 <img src="https://www.zhihu.com/equation?tex=dudv" alt="[公式]"> 的消去也是不严谨的，而极限微积分中应该重新用极限的方法进行证明，这里不再列出。</li></ul><p>古典微积分其实已经被摒弃了，我们应该知道这一点，重新从极限的角度去认识微积分。</p><h5 id="3-3-古典微积分的用处"><a href="#3-3-古典微积分的用处" class="headerlink" title="3.3 古典微积分的用处"></a><strong>3.3 古典微积分的用处</strong></h5><p>我们应该从古典微积分，以直代曲、化整为零的数学思想出发去开始认识微积分。</p><p>并且，莱布尼兹一直认为数学符号应该具有启发性，他设计的微积分符号确实很符合直觉，我们可以继续借用他的符号来描述微积分。</p><h4 id="4-无穷小量的逆袭"><a href="#4-无穷小量的逆袭" class="headerlink" title="4 无穷小量的逆袭"></a><strong>4 无穷小量的逆袭</strong></h4><p>有的数学家还是对无穷小量念念不忘，最后真的发明了既可以兼容无穷小量又不会出现问题的实数， <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25B6%2585%25E5%25AE%259E%25E6%2595%25B0_%28%25E9%259D%259E%25E6%25A0%2587%25E5%2587%2586%25E5%2588%2586%25E6%259E%2590%29">超实数</a> 。</p><p>基于超实数，数学家又重新定义了微积分，这次定义的微积分又很像莱布尼兹时代的微积分。这门学科被称为非标准分析（对应的，基于我们没有无穷小量的实数体系的微积分，就是标准分析）。我对于超实数并不了解，大家感兴趣可以去学习非标准分析课程。</p><p>链接：<a href="https://www.zhihu.com/question/22199657/answer/115178055" target="_blank" rel="noopener">https://www.zhihu.com/question/22199657/answer/115178055</a></p><p>来源：知乎</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导数与微分的理解&quot;&gt;&lt;a href=&quot;#导数与微分的理解&quot; class=&quot;headerlink&quot; title=&quot;导数与微分的理解&quot;&gt;&lt;/a&gt;导数与微分的理解&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;首先高数课本上导数的定义：&quot;&gt;&lt;a href=&quot;#首先高数课本上导数的定义：&quot; class=&quot;headerlink&quot; title=&quot;首先高数课本上导数的定义：&quot;&gt;&lt;/a&gt;首先高数课本上导数的定义：
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向对象分析（二）</title>
    <link href="http://yoursite.com/2020/03/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/面向对象分析（二）/</id>
    <published>2020-03-19T02:27:26.596Z</published>
    <updated>2020-03-19T09:42:01.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标识概念类和对象"><a href="#标识概念类和对象" class="headerlink" title="标识概念类和对象"></a>标识概念类和对象</h2><p>EXAMPLE：部分需求文档<a id="more"></a></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/yTEmRwndtgdT.png?imageslim" alt="mark"></p><p>​    <strong>用户</strong>可以通过主要的<strong>特征</strong>指定每一项<strong>产品</strong>，包括产品的<strong>名字</strong>和产品的<strong>号码</strong>。如果<strong>条形码</strong>和<strong>产品</strong>不匹配，<strong>信息窗口</strong>会报告<strong>错误</strong>并且将其保存到<strong>错误日志</strong>。所有<strong>交易信息</strong>的<strong>最终报告</strong>必须按照7.A节中规定的结构。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>​    类，表示一组具有相同行为，属性的对象</li><li>​    类，在表示对象群体的时候，一般用单数</li><li>​    根据类，可以创建所需要数量的对象个体类名的选择很重要！要能够帮助大家理解</li></ul><p>​    如Customer？Or User：哪个更好，视情况而定</p><p>可能的抉择：一个名词，是作为概念类合适，还是作为某个类的属性合适？</p><p>​    eg：员工的地址应该作为单独的类还是属性</p><h3 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h3><p>​    对问题了解的约细越透彻，越有把握做出决定。</p><p>​    <img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/tOyrHBzxJWPy.png?imageslim" alt="mark"></p><p>练习：</p><p>​    eg：产品描述与产品</p><p>​    eg：手机的PIN吗与手机用户？因为PIN码本身可以处在“激活”，“锁定”，“正常”，“失效”等状态</p><h3 id="在适当的细节层面定义概念类"><a href="#在适当的细节层面定义概念类" class="headerlink" title="在适当的细节层面定义概念类"></a>在适当的细节层面定义概念类</h3><p>​    当发现一个类非常复杂时，要考虑拆分成多个小一点的类</p><p>​    但是，又不能有太多的类</p><p>​    <img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/iFpU42nqMGzz.png?imageslim" alt="mark"></p><p>这些都取决于我们要解决的问题</p><h3 id="类的选择依赖于应用领域"><a href="#类的选择依赖于应用领域" class="headerlink" title="类的选择依赖于应用领域"></a>类的选择依赖于应用领域</h3><h3 id="在标识概念类的过程中"><a href="#在标识概念类的过程中" class="headerlink" title="在标识概念类的过程中"></a>在标识概念类的过程中</h3><ul><li>​    同时要考虑每个类的职责分配</li><li>​    但是不需要在领域模型中明示</li></ul><h3 id="总的原则"><a href="#总的原则" class="headerlink" title="总的原则"></a>总的原则</h3><ul><li>​    即将要开发的系统，每项任务（每个职责）都需要有一个或多个类去处理</li><li>​    标识成类的操作（一般是动词）</li><li>​    在分析，设计的早期，不必要定义每个类的每个操作</li><li>​    一开始，标识成较为粗狂的职责描述</li></ul><p>​    <img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/vPc7x6J0r7Vl.png?imageslim" alt="mark"></p><p>​    </p><h2 id="CRC方法标识概念类（Class类-Responsibilities职责-Collaborations协作）"><a href="#CRC方法标识概念类（Class类-Responsibilities职责-Collaborations协作）" class="headerlink" title="CRC方法标识概念类（Class类 Responsibilities职责 Collaborations协作）"></a>CRC方法标识概念类（Class类 Responsibilities职责 Collaborations协作）</h2><p>​    一种发现概念类并分配职责的途径</p><p>​    从“领域类，用例”到设计类</p><p>​    <img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/iNW6Fj4uufV6.png?imageslim" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/kDd1e1IWepKU.png?imageslim" alt="mark"></p><h3 id="CRC的输入信息：用例模型"><a href="#CRC的输入信息：用例模型" class="headerlink" title="CRC的输入信息：用例模型"></a>CRC的输入信息：用例模型</h3><p>用例模型：用例图，边界，用户描述，清楚地面熟了系统需求，作为CRC概念类分析的起点</p><p>用例描述的正常事件流，异常事件流，可以作为CRC的“角色扮演”的脚本。</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/VY3smiFMEz8H.png?imageslim" alt="mark"></p><h3 id="CRC案例：绘图工具软件"><a href="#CRC案例：绘图工具软件" class="headerlink" title="CRC案例：绘图工具软件"></a>CRC案例：绘图工具软件</h3><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/ADosqhn5PtbG.png?imageslim" alt="mark"></p><p>用例：画图 移动图形 修改大小 连接形状 擦掉一个形状 擦掉连接</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/04rX5CwarrkY.png?imageslim" alt="mark"></p><p>​    <img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/eYD0F7rKmQkI.png?imageslim" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/z6sJwRNPpwPa.png?imageslim" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/RU4K5lRMfMN2.png?imageslim" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/wUjXjJVjQ4N6.png?imageslim" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/Ab2fl4Uqj949.png?imageslim" alt="mark"></p><h3 id="CRC方法建模的一些规则"><a href="#CRC方法建模的一些规则" class="headerlink" title="CRC方法建模的一些规则"></a>CRC方法建模的一些规则</h3><p>CRC指导</p><p>CRC的card由团队来实现，由1-2个领域专家，1-2分析师，1个面向对象分析师，一位引导者，客户</p><p>头脑风暴：收集各种各样的想法，比较这些想法并进行合成</p><p>头脑风暴的原则：</p><p>​    所有想法都是好的想法</p><p>​    提出问题时很激烈，之后沉思分析</p><p>​    每一个人都有机会表达</p><p>​    有点小幽默</p><p>头脑风暴的步骤</p><p>​    <img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/HDzdI8UNJW3Y.png?imageslim" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/NmSkpC6c6RjE.png?imageslim" alt="mark"></p><p>案例分析</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/LRIUY4cFY7rQ.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标识概念类和对象&quot;&gt;&lt;a href=&quot;#标识概念类和对象&quot; class=&quot;headerlink&quot; title=&quot;标识概念类和对象&quot;&gt;&lt;/a&gt;标识概念类和对象&lt;/h2&gt;&lt;p&gt;EXAMPLE：部分需求文档
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向对象分析（一）</title>
    <link href="http://yoursite.com/2020/03/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/18/面向对象分析（一）/</id>
    <published>2020-03-18T02:26:29.839Z</published>
    <updated>2020-03-19T01:49:21.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象分析（一）"><a href="#面向对象分析（一）" class="headerlink" title="面向对象分析（一）"></a>面向对象分析（一）</h1><p>分析即把用户需求转换为系统需求</p><p>[TOC]</p><a id="more"></a><h2 id="面向对象的主要步骤："><a href="#面向对象的主要步骤：" class="headerlink" title="面向对象的主要步骤："></a>面向对象的主要步骤：</h2><ol><li>识别对象</li><li>组织对象</li><li>定义对象之间的关系</li><li>定义对象的操作</li><li>定义对象内部细节</li></ol><p>领域（用户角度） 系统（开发人员的角度）</p><p>概念模型：表示了问题领域的“概念”及其关系，也称为领域模型。UML图形表示为“没有定义操作的类图”。概念类 == 领域概念</p><h2 id="如何找到概念类："><a href="#如何找到概念类：" class="headerlink" title="如何找到概念类："></a>如何找到概念类：</h2><h3 id="1-概念模型-即“名词法”"><a href="#1-概念模型-即“名词法”" class="headerlink" title="1.概念模型 即“名词法”"></a>1.概念模型 即“名词法”</h3><ol><li><p>​    重用或者修改已有的模型</p></li><li><p>​    借助行业，公司内部法的“概念类列表”</p></li><li><p>​    ☆在需求描述中查询名词（短语）：</p><p>1.在问题领域的文本描述中，标识出名词，名词短语，把他们作为候选的概念类或者属性。</p><p>2.对发现的名称短语进行分析，辨别是合适的概念类吗？概念可以合并吗？等等</p><p>3.定义概念类之间的关系4.定义概念类之间的属性</p><p>注意：</p><p>​    不能机械的转换“名称”–&gt;“概念类”</p><p>​    自然语言描述的文字有歧义，重复，一词多意，一意多次等，要仔细 分析</p><p>​    比如英语，复数一般就不需要了，students\student,只要student即可。</p></li></ol><h3 id="名词法案例：用例：废品回收机"><a href="#名词法案例：用例：废品回收机" class="headerlink" title="名词法案例：用例：废品回收机"></a>名词法案例：用例：废品回收机</h3><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200318/b55LmrRVgifY.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200318/E34RRjt6EVD7.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/69tADxr6Ddq2.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200318/fKVhA3e29gSw.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/Vy7L7YPGC1T4.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/PDALShJLAxtG.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/TRa403mmOaFA.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/egnt4mKAPw5A.PNG" alt="mark"></p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/a54rH7dFuFoE.png?imageslim" alt="mark"></p><h3 id="2分析模型法（边界-实体-控制）"><a href="#2分析模型法（边界-实体-控制）" class="headerlink" title="2分析模型法（边界 实体 控制）"></a>2分析模型法（边界 实体 控制）</h3><p>2.1分析模型法定义   </p><p>2.2特性：行为， 展示(输入/输出) ，信息</p><p>2.3分析模型的表示符号      边界类 控制类 信息</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/gesWRGPLCd7g.PNG" alt="mark"></p><p>2.4分析模型的语义</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/6xfiW0G8KgWW.PNG" alt="mark"></p><p>实体对象对显示系统状态的信息建模。这些信息通常用于记录操作的效果，因此与系统的行为相关。边界/接口对象对输入和输出以及处理它们的操作建模。控制对象对功能/操作进行建模，用于验证和决定是否处理接口对象的信息并将其传递给实体对象，或以其他方式传递。</p><p><img src="C:%5CUsers%5CDZL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584498152284.png" alt="1584498152284"></p><h3 id="分析模型案例：废品回收机"><a href="#分析模型案例：废品回收机" class="headerlink" title="分析模型案例：废品回收机"></a>分析模型案例：废品回收机</h3><p>​    找到和接口相关的概念：打印机接口 用户面板</p><p>​    找到和实体相关的概念：罐子 计算  保存数据的</p><p>​    找到控制相关的概念：代表的整个系统 Depoist item receiver</p><p><img src="http://q7e5szr7k.bkt.clouddn.com/blog/20200319/6YHubU8iq2Sa.png?imageslim" alt="mark"></p><h3 id="3-CRC法，类、职责，协作"><a href="#3-CRC法，类、职责，协作" class="headerlink" title="3.CRC法，类、职责，协作"></a>3.CRC法，类、职责，协作</h3><p>见下篇</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向对象分析（一）&quot;&gt;&lt;a href=&quot;#面向对象分析（一）&quot; class=&quot;headerlink&quot; title=&quot;面向对象分析（一）&quot;&gt;&lt;/a&gt;面向对象分析（一）&lt;/h1&gt;&lt;p&gt;分析即把用户需求转换为系统需求&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>银行ATM机java swing实现</title>
    <link href="http://yoursite.com/2019/12/19/%E9%93%B6%E8%A1%8CATM%E6%9C%BAjava%20swing%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/19/银行ATM机java swing实现/</id>
    <published>2019-12-19T13:04:06.273Z</published>
    <updated>2020-03-19T09:42:37.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA-Swing-JDBC-实现银行ATM机（1）"><a href="#JAVA-Swing-JDBC-实现银行ATM机（1）" class="headerlink" title="JAVA Swing JDBC 实现银行ATM机（1）"></a>JAVA Swing JDBC 实现银行ATM机（1）</h2><p>编写ATM机，实现ATM机的登录，查询，打印凭条，存款，取款，转账等功能</p><p>后台有ATM管路，和银行卡管理<a id="more"></a></p><p>采用mysql数据库 druid连接池 JDBC JFrame navicat</p><p>1.建数据库表</p><p>atm表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>atmID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘机号’ ,<br><code>astate</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT ‘运行’ COMMENT ‘状态’ ,<br><code>atmBalance</code>  decimal(30,0) NOT NULL DEFAULT 0 COMMENT ‘ATM余额’ ,<br>PRIMARY KEY (<code>atmID</code>)<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>ROW_FORMAT=COMPACT<br>;</p><p>bank表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>bankID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘银行ID’ ,<br><code>bankname</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘银行名称’ ,<br>PRIMARY KEY (<code>bankID</code>)<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>ROW_FORMAT=COMPACT<br>;</p><p>bankcard表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>idCard</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘卡号’ ,<br><code>password</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘密码’ ,<br><code>userID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘用户id’ ,<br><code>balance</code>  decimal(30,0) NOT NULL COMMENT ‘余额’ ,<br><code>wrong</code>  int(10) NOT NULL COMMENT ‘密码错误次数’ ,<br><code>state</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘银行卡状态’ ,<br><code>bankID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘银行ID’ ,<br>PRIMARY KEY (<code>idCard</code>),<br>FOREIGN KEY (<code>userID</code>) REFERENCES <code>user</code> (<code>userID</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>FOREIGN KEY (<code>bankID</code>) REFERENCES <code>bank</code> (<code>bankID</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>INDEX <code>userID</code> (<code>userID</code>) USING BTREE ,<br>INDEX <code>bankID</code> (<code>bankID</code>) USING BTREE<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>ROW_FORMAT=COMPACT<br>;</p><p>deposit表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>id</code>  int(30) NOT NULL AUTO_INCREMENT COMMENT ‘序号’ ,<br><code>idCard</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘卡号’ ,<br><code>dtime</code>  timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘存款时间’ ,<br><code>dmoney</code>  decimal(10,0) NOT NULL COMMENT ‘金额’ ,<br><code>atmID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘设备号’ ,<br><code>mID</code>  varchar(250) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘冠字号’ ,<br>PRIMARY KEY (<code>id</code>),<br>FOREIGN KEY (<code>idCard</code>) REFERENCES <code>bankcard</code> (<code>idCard</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>FOREIGN KEY (<code>atmID</code>) REFERENCES <code>atm</code> (<code>atmID</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>INDEX <code>idCard</code> (<code>idCard</code>) USING BTREE ,<br>INDEX <code>atmID</code> (<code>atmID</code>) USING BTREE<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>AUTO_INCREMENT=6<br>ROW_FORMAT=COMPACT<br>;</p><p>CREATE DEFINER=<code>root</code>@<code>localhost</code> TRIGGER <code>in</code> AFTER INSERT ON <code>NewTable</code><br>FOR EACH ROW begin<br>insert into receipt(idCard,type,money,time,atmID,mID)<br>values(new.idCard,’存款’,new.dmoney,new.dtime,new.atmID,new.mID);<br>update bankcard set balance = balance + new.dmoney where idCard = new.idCard;<br>end;</p><p>province表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>provinceID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘省份ID’ ,<br><code>province</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘省份名称’ ,<br>PRIMARY KEY (<code>provinceID</code>),<br>INDEX <code>province</code> (<code>province</code>) USING BTREE<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>ROW_FORMAT=COMPACT<br>;</p><p>receipt表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>id</code>  int(30) NOT NULL AUTO_INCREMENT ,<br><code>idCard</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘卡号’ ,<br><code>type</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘交易类型’ ,<br><code>money</code>  decimal(30,0) NOT NULL COMMENT ‘金额’ ,<br><code>time</code>  datetime NOT NULL COMMENT ‘时间’ ,<br><code>atmID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘设备号’ ,<br><code>mID</code>  varchar(250) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘冠字号’ ,<br>PRIMARY KEY (<code>id</code>)<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>AUTO_INCREMENT=17<br>ROW_FORMAT=COMPACT<br>;</p><p>region表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>areaID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘地区ID’ ,<br><code>area</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘地区名称’ ,<br>PRIMARY KEY (<code>areaID</code>)<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>ROW_FORMAT=COMPACT<br>;</p><p>transfer表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>id</code>  int(30) NOT NULL AUTO_INCREMENT COMMENT ‘序号’ ,<br><code>idCard</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘卡号’ ,<br><code>tbankID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘交易卡号’ ,<br><code>ttime</code>  timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘转账时间’ ,<br><code>tmoney</code>  decimal(10,0) NOT NULL COMMENT ‘转账金额’ ,<br><code>ttype</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘转账类型’ ,<br><code>cost</code>  decimal(10,0) NOT NULL COMMENT ‘手续费’ ,<br><code>atmID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘设备号’ ,<br><code>mID</code>  varchar(250) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘冠字号’ ,<br>PRIMARY KEY (<code>id</code>),<br>FOREIGN KEY (<code>idCard</code>) REFERENCES <code>bankcard</code> (<code>idCard</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>FOREIGN KEY (<code>atmID</code>) REFERENCES <code>atm</code> (<code>atmID</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>INDEX <code>idCard</code> (<code>idCard</code>) USING BTREE ,<br>INDEX <code>atmID</code> (<code>atmID</code>) USING BTREE<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>AUTO_INCREMENT=9<br>ROW_FORMAT=COMPACT<br>;</p><p>CREATE DEFINER=<code>root</code>@<code>localhost</code> TRIGGER <code>trans</code> AFTER INSERT ON <code>NewTable</code><br>FOR EACH ROW begin<br>update bankcard set balance = balance + new.tmoney where idCard = new.tbankID;<br>update bankcard set balance = balance - new.tmoney - new.cost where idCard = new.idCard;<br>if new.ttype=0<br>then<br>insert into receipt(idCard,type,money,time,atmID,mID)<br>values(new.idCard,’同行转账’,new.tmoney,new.ttime,new.atmID,new.mID);<br>end if;<br>if new.ttype=1<br>then<br>insert into receipt(idCard,type,money,time,atmID,mID)<br>values(new.idCard,’行外转账’,new.tmoney,new.ttime,new.atmID,new.mID);<br>insert into receipt(idCard,type,money,time,atmID,mID)<br>values(new.idCard,’转账手续费’,new.cost,new.ttime,new.atmID,new.mID);<br>end if;<br>end;</p><p>user表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>userID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘用户ID’ ,<br><code>name</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘姓名’ ,<br><code>sex</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘性别’ ,<br><code>age</code>  int(30) NOT NULL COMMENT ‘年龄’ ,<br><code>provinceID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘省份ID’ ,<br><code>areaID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘地区ID’ ,<br>PRIMARY KEY (<code>userID</code>),<br>INDEX <code>provinceID</code> (<code>provinceID</code>) USING BTREE ,<br>INDEX <code>areaID</code> (<code>areaID</code>) USING BTREE<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>ROW_FORMAT=COMPACT<br>;</p><p>withdrawal表</p><p>CREATE TABLE <code>NewTable</code> (<br><code>id</code>  int(30) NOT NULL AUTO_INCREMENT COMMENT ‘序号’ ,<br><code>idCard</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘卡号’ ,<br><code>wtime</code>  timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘取款时间’ ,<br><code>wmoney</code>  decimal(10,0) NOT NULL COMMENT ‘金额’ ,<br><code>atmID</code>  varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘设备号’ ,<br><code>mID</code>  varchar(250) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ‘冠字号’ ,<br>PRIMARY KEY (<code>id</code>),<br>FOREIGN KEY (<code>idCard</code>) REFERENCES <code>bankcard</code> (<code>idCard</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>FOREIGN KEY (<code>atmID</code>) REFERENCES <code>atm</code> (<code>atmID</code>) ON DELETE RESTRICT ON UPDATE RESTRICT,<br>INDEX <code>idCard</code> (<code>idCard</code>) USING BTREE ,<br>INDEX <code>atmID</code> (<code>atmID</code>) USING BTREE<br>)<br>ENGINE=InnoDB<br>DEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci<br>AUTO_INCREMENT=3<br>ROW_FORMAT=COMPACT<br>;</p><p>CREATE DEFINER=<code>root</code>@<code>localhost</code> TRIGGER <code>out</code> AFTER INSERT ON <code>NewTable</code><br>FOR EACH ROW begin<br>insert into receipt(idCard,type,money,time,atmID,mID)<br>values(new.idCard,’取款’,new.wmoney,new.wtime,new.atmID,new.mID);<br>update bankcard set balance = balance - new.wmoney where idCard = new.idCard;<br>end;</p><p>2.导入Jar包</p><p>mysql-connector-java-5.1.37-bin</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JAVA-Swing-JDBC-实现银行ATM机（1）&quot;&gt;&lt;a href=&quot;#JAVA-Swing-JDBC-实现银行ATM机（1）&quot; class=&quot;headerlink&quot; title=&quot;JAVA Swing JDBC 实现银行ATM机（1）&quot;&gt;&lt;/a&gt;JAVA Swing JDBC 实现银行ATM机（1）&lt;/h2&gt;&lt;p&gt;编写ATM机，实现ATM机的登录，查询，打印凭条，存款，取款，转账等功能&lt;/p&gt;
&lt;p&gt;后台有ATM管路，和银行卡管理
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>利用jdbc mysql简单实现职员管理系统</title>
    <link href="http://yoursite.com/2019/11/16/%E5%88%A9%E7%94%A8jdbc%20mysql%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E8%81%8C%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/11/16/利用jdbc mysql简单实现职员管理系统/</id>
    <published>2019-11-16T11:41:18.370Z</published>
    <updated>2020-03-19T09:42:23.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用jdbc-mysql简单实现职员管理系统"><a href="#利用jdbc-mysql简单实现职员管理系统" class="headerlink" title="利用jdbc mysql简单实现职员管理系统"></a>利用jdbc mysql简单实现职员管理系统</h1><h2 id="1-安装mysql数据库，下载jdba的mysql的jar包"><a href="#1-安装mysql数据库，下载jdba的mysql的jar包" class="headerlink" title="1.安装mysql数据库，下载jdba的mysql的jar包"></a>1.安装mysql数据库，下载jdba的mysql的jar包<a id="more"></a></h2><p>mysql下载：<a href="https://pan.baidu.com/s/1k0146Keg-ugsJihZaRR-Ng" target="_blank" rel="noopener">https://pan.baidu.com/s/1k0146Keg-ugsJihZaRR-Ng</a></p><p>jar包下载：<a href="https://pan.baidu.com/s/1LmbGGtDRVMocT_JWRxYz7A" target="_blank" rel="noopener">https://pan.baidu.com/s/1LmbGGtDRVMocT_JWRxYz7A</a></p><h2 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h2><p><img src="http://q0lhqnf0a.bkt.clouddn.com/6.PNG" alt=""></p><h2 id="3-在项目目录下新建文件夹lib，将jar包复制进去，右击lib文件夹选择Add-as-Library…，选择moudle-library点击ok。"><a href="#3-在项目目录下新建文件夹lib，将jar包复制进去，右击lib文件夹选择Add-as-Library…，选择moudle-library点击ok。" class="headerlink" title="3.在项目目录下新建文件夹lib，将jar包复制进去，右击lib文件夹选择Add as Library…，选择moudle library点击ok。"></a>3.在项目目录下新建文件夹lib，将jar包复制进去，右击lib文件夹选择Add as Library…，选择moudle library点击ok。<!--more--></h2><p><img src="http://q0lhqnf0a.bkt.clouddn.com/1.PNG" alt=""></p><p><img src="http://q0lhqnf0a.bkt.clouddn.com/2.PNG" alt=""></p><h2 id="4-创建编写JDBCUtils工具类"><a href="#4-创建编写JDBCUtils工具类" class="headerlink" title="4.创建编写JDBCUtils工具类"></a>4.创建编写JDBCUtils工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenlun.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;   <span class="comment">//你数据库的用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PSD = <span class="string">"root"</span>;    <span class="comment">//你数据库的密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">"jdbc:mysql:///system"</span>;  <span class="comment">//数据库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4. 注册驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(URL, USER, PSD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-创建编写增删改查方法接口和实现类"><a href="#5-创建编写增删改查方法接口和实现类" class="headerlink" title="5.创建编写增删改查方法接口和实现类"></a>5.创建编写增删改查方法接口和实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenlun.control;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package cn.chenlun.control;</span><br><span class="line"></span><br><span class="line">import cn.chenlun.util.JDBCUtils;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class MethodImpl implements Method &#123;</span><br><span class="line">    @Override</span><br><span class="line">    </span><br><span class="line">    //查询</span><br><span class="line">    public void query() throws SQLException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;select * from inform&quot;;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        while (resultSet.next()) &#123;</span><br><span class="line">            String id = resultSet.getString(&quot;id&quot;);</span><br><span class="line">            String name = resultSet.getString(&quot;name&quot;);</span><br><span class="line">            String sex = resultSet.getString(&quot;sex&quot;);</span><br><span class="line">            int queke = resultSet.getInt(&quot;queke&quot;);</span><br><span class="line">            String apartment = resultSet.getString(&quot;apartment&quot;);</span><br><span class="line">            int salary = resultSet.getInt(&quot;salary&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;工号:&quot; + id +&quot;,姓名:&quot; + name + &quot;,性别:&quot; + sex + &quot;,缺课数:&quot; + queke + &quot;,系部:&quot;</span><br><span class="line">            + apartment + &quot;,工资:&quot; + salary);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        JDBCUtils.close(resultSet,preparedStatement,connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//添加</span><br><span class="line">    @Override</span><br><span class="line">    public void add() throws SQLException&#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入添加的记录&quot;);</span><br><span class="line">        System.out.println(&quot;工号&quot;);</span><br><span class="line">        String id = sc.next();</span><br><span class="line">        System.out.println(&quot;姓名&quot;);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        System.out.println(&quot;性别&quot;);</span><br><span class="line">        String sex = sc.next();</span><br><span class="line">        System.out.println(&quot;缺课数量&quot;);</span><br><span class="line">        int queke = sc.nextInt();</span><br><span class="line">        System.out.println(&quot;系部&quot;);</span><br><span class="line">        String apartment = sc.next();</span><br><span class="line">        System.out.println(&quot;基本工资&quot;);</span><br><span class="line">        int salary = sc.nextInt();</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;insert into inform values (?,?,?,?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pt = connection.prepareStatement(sql);</span><br><span class="line">        pt.setString(1,id);</span><br><span class="line">        pt.setString(2,name);</span><br><span class="line">        pt.setString(3,sex);</span><br><span class="line">        pt.setInt(4,queke);</span><br><span class="line">        pt.setString(5,apartment);</span><br><span class="line">        pt.setInt(6,salary);</span><br><span class="line">        int resultSet = pt.executeUpdate();</span><br><span class="line">        System.out.println(&quot;成功插入&quot;+resultSet+&quot;条记录&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">    @Override</span><br><span class="line">    public void delete() throws SQLException &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;delete from inform where name = ?&quot;;</span><br><span class="line">        System.out.println(&quot;你要删除人的姓名:&quot;);</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        preparedStatement.setString(1,s);</span><br><span class="line">        int resultSet = preparedStatement.executeUpdate();</span><br><span class="line">        System.out.println(&quot;删除了&quot;+resultSet+&quot;条记录&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">    @Override</span><br><span class="line">    public void modify() throws SQLException &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;update inform set sex=?,queke=?,apartment=?,salary=? where name = ?&quot;;</span><br><span class="line">        System.out.println(&quot;输入你想修改人的姓名&quot;);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        System.out.println(&quot;性别&quot;);</span><br><span class="line">        String asex = scanner.next();</span><br><span class="line">        System.out.println(&quot;缺课数&quot;);</span><br><span class="line">        int aqueke = scanner.nextInt();</span><br><span class="line">        System.out.println(&quot;系部&quot;);</span><br><span class="line">        String aapartment = scanner.next();</span><br><span class="line">        System.out.println(&quot;基本工资&quot;);</span><br><span class="line">        int asalary = scanner.nextInt();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        preparedStatement.setString(1,asex);</span><br><span class="line">        preparedStatement.setInt(2,aqueke);</span><br><span class="line">        preparedStatement.setString(3,aapartment);</span><br><span class="line">        preparedStatement.setInt(4,asalary);</span><br><span class="line">        preparedStatement.setString(5,name);</span><br><span class="line">        int resultSet = preparedStatement.executeUpdate();</span><br><span class="line">        System.out.println(&quot;成功修改&quot;+resultSet+&quot;条数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-创建编写主类"><a href="#6-创建编写主类" class="headerlink" title="6.创建编写主类"></a>6.创建编写主类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenlun.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.chenlun.control.MethodImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            ui();</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            MethodImpl m = <span class="keyword">new</span> MethodImpl();</span><br><span class="line">            <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                m.query();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">                m.add();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">                m.modify();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span>)</span><br><span class="line">                m.delete();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"输入错误 请重新输入:"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ui</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1.查询员工信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2.添加员工信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3.修改员工信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4.删除员工信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><p><img src="http://q0lhqnf0a.bkt.clouddn.com/3.PNG" alt=""></p><p><img src="http://q0lhqnf0a.bkt.clouddn.com/4.PNG" alt=""></p><p>做的比较简陋,也并未使用数据库连接池,和对象的的封装。</p><p>还有改进之处，望见谅。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;利用jdbc-mysql简单实现职员管理系统&quot;&gt;&lt;a href=&quot;#利用jdbc-mysql简单实现职员管理系统&quot; class=&quot;headerlink&quot; title=&quot;利用jdbc mysql简单实现职员管理系统&quot;&gt;&lt;/a&gt;利用jdbc mysql简单实现职员管理系统&lt;/h1&gt;&lt;h2 id=&quot;1-安装mysql数据库，下载jdba的mysql的jar包&quot;&gt;&lt;a href=&quot;#1-安装mysql数据库，下载jdba的mysql的jar包&quot; class=&quot;headerlink&quot; title=&quot;1.安装mysql数据库，下载jdba的mysql的jar包&quot;&gt;&lt;/a&gt;1.安装mysql数据库，下载jdba的mysql的jar包
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yoursite.com/2019/11/07/%E8%B4%AA%E5%BF%83/"/>
    <id>http://yoursite.com/2019/11/07/贪心/</id>
    <published>2019-11-07T12:06:37.739Z</published>
    <updated>2019-11-08T09:12:03.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="分治法的基本思想"><a href="#分治法的基本思想" class="headerlink" title="分治法的基本思想"></a>分治法的基本思想</h2><p>分治法的基本思想是将一个大规模的问题划分为若干个小规模的子问题，这些子问题相互独立且与原问题相同。递归的解决这些子问题，然后将各个子问题的解合并得到原问题的解。</p><a id="more"></a><p>而根据分治法的分割原则，应该把原问题分成多少个子问题才合适呢？没个子问题是否规模相等或怎样才最适当？通过大量实践发现，最好使子问题的规模大致相同，即将问题划分为大小相等的k个子问题比较合适。</p><p><img src="https://img-blog.csdn.net/20161203163252550" alt=""></p><h2 id="二分搜索法"><a href="#二分搜索法" class="headerlink" title="二分搜索法"></a>二分搜索法</h2><p>二分搜索是分治思想的典型例子</p><blockquote><p><strong>二分搜索</strong>（英语：binary search），也称<strong>折半搜索</strong>（英语：half-interval search）、<strong>对数搜索</strong>（英语：logarithmic search），是一种在<strong>有序数组</strong>中查找某一特定元素的搜索<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法</a>。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//while循环的方法</span><br><span class="line">int BinarySearch(int a[],int n,int x)&#123;      //n为元素个数，k为搜索的数</span><br><span class="line">int left = 0；</span><br><span class="line">int right = n-1；</span><br><span class="line">while (left &lt;= right)&#123;</span><br><span class="line">int middle = (left + right)/2;</span><br><span class="line">if (x == a[middle])</span><br><span class="line">return middle;</span><br><span class="line">else if (x&gt;middle)</span><br><span class="line">left = middle + 1;</span><br><span class="line">else</span><br><span class="line">right = middle - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">//递归的方法(java实现)</span><br><span class="line">public static int BinSreachOfRecursion(int[] arr, int start, int end,int key) &#123; </span><br><span class="line">//start开始 end结束</span><br><span class="line">if(arr == null) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">//这个判断，必不可少，因为它就是递归种植的条件呀~</span><br><span class="line">if(start &gt; end) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (end - start)/2 + start;</span><br><span class="line">if(arr[mid] &gt; key)&#123;</span><br><span class="line">return BinSreachOfRecursion(arr, start, mid-1, key);</span><br><span class="line">&#125; else if(arr[mid] &lt; key) &#123;</span><br><span class="line">return BinSreachOfRecursion(arr, mid+1, end, key);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p><strong>大整数相乘：</strong>A、B两个整数，A有n位（123456……n），B有m位（123456……m），一般的思路是像最初学习乘法时一样逐位相乘后相加，但是这样做算法的复杂度过高，但这仍然是解题的基本思想。</p><p>既然提到分治，那么如何分，怎么治？下面参考如下</p><p><a href="https://blog.csdn.net/qq_36165148/article/details/81132525" target="_blank" rel="noopener">https://blog.csdn.net/qq_36165148/article/details/81132525</a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multi</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len_A = A.length();</span><br><span class="line">    <span class="keyword">int</span> len_B = B.length();</span><br><span class="line">    <span class="keyword">if</span> (len_A == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len_B == <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">//最基本的情况：A和B都是一位数，把A、B从string转为int（我这里用的stringstream），然后相转string型return回去。</span></span><br><span class="line">            ss &lt;&lt; A;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            ss &gt;&gt; a;</span><br><span class="line">            ss.clear();</span><br><span class="line">            ss &lt;&lt; B;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            ss &gt;&gt; b;</span><br><span class="line">            ss.clear();</span><br><span class="line">            ss &lt;&lt; b*a;</span><br><span class="line">            <span class="built_in">string</span> str_out;</span><br><span class="line">            ss &gt;&gt; str_out;</span><br><span class="line">            ss.clear();</span><br><span class="line">            <span class="keyword">return</span> str_out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//A是个位数，B不是的情况下，按照分治的思想把B分开分别与A相乘。</span></span><br><span class="line">            <span class="built_in">string</span> B1, B2;</span><br><span class="line">            B1 = B.substr(<span class="number">0</span>, len_B / <span class="number">2</span>);</span><br><span class="line">            B2 = B.substr(len_B / <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">string</span> AB1 = multi(A, B1);</span><br><span class="line">            <span class="built_in">string</span> AB2 = multi(A, B2);</span><br><span class="line">            <span class="keyword">if</span> (AB2.length() &gt; B2.length()) &#123;</span><br><span class="line">                <span class="built_in">string</span> str = AB2.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                ss &lt;&lt; str;</span><br><span class="line">                <span class="keyword">int</span> ab2;</span><br><span class="line">                ss &gt;&gt; ab2;</span><br><span class="line">                ss.clear();</span><br><span class="line">                ss &lt;&lt; AB1;</span><br><span class="line">                <span class="keyword">int</span> ab1;</span><br><span class="line">                ss &gt;&gt; ab1;</span><br><span class="line">                ss.clear();</span><br><span class="line">                ss &lt;&lt; ab1 + ab2;</span><br><span class="line">                ss &gt;&gt; AB1;</span><br><span class="line">                ss.clear();</span><br><span class="line">                <span class="keyword">return</span> AB1 + AB2.substr(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> AB1 + AB2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len_B == <span class="number">1</span>) &#123;  <span class="comment">//B是个位数，A不是的情况与上述A是个位数B不是的情况相同。</span></span><br><span class="line">            <span class="built_in">string</span> A1, A2;</span><br><span class="line">            A1 = A.substr(<span class="number">0</span>, len_A / <span class="number">2</span>);</span><br><span class="line">            A2 = A.substr(len_A / <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">string</span> A1B = multi(A1, B);</span><br><span class="line">            <span class="built_in">string</span> A2B = multi(A2, B);</span><br><span class="line">            <span class="keyword">if</span> (A2B.length() &gt; A2.length()) &#123;</span><br><span class="line">                <span class="built_in">string</span> str = A2B.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                ss &lt;&lt; str;</span><br><span class="line">                <span class="keyword">int</span> a2b;</span><br><span class="line">                ss &gt;&gt; a2b;</span><br><span class="line">                ss.clear();</span><br><span class="line">                ss &lt;&lt; A1B;</span><br><span class="line">                <span class="keyword">int</span> a1b;</span><br><span class="line">                ss &gt;&gt; a1b;</span><br><span class="line">                ss.clear();</span><br><span class="line">                ss &lt;&lt; a1b + a2b;</span><br><span class="line">                ss &gt;&gt; A1B;</span><br><span class="line">                ss.clear();</span><br><span class="line">                <span class="keyword">return</span> A1B + A2B.substr(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> A1B + A2B;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//A和B都不是个位数，就按照上述方法分治就可以了，只是为了最后相加的时候方便，把返回的四个部分都用0凑成了位数相同的。</span></span><br><span class="line">            <span class="built_in">string</span> A1, A2, B1, B2;</span><br><span class="line">            A1 = A.substr(<span class="number">0</span>, len_A / <span class="number">2</span>);</span><br><span class="line">            A2 = A.substr(len_A / <span class="number">2</span>);</span><br><span class="line">            B1 = B.substr(<span class="number">0</span>, len_B / <span class="number">2</span>);</span><br><span class="line">            B2 = B.substr(len_B / <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">string</span> part1_ = multi(A1, B1);</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">part1_0</span><span class="params">(A2.length()+B2.length(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            part1_ = part1_ + part1_0;</span><br><span class="line">            <span class="built_in">string</span> part2_ = multi(A2, B2);</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">part2_00</span><span class="params">(part1_.length() - part2_.length(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            part2_ = part2_00 + part2_;</span><br><span class="line">            <span class="built_in">string</span> part3_ = multi(A1, B2);</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">part3_0</span><span class="params">(A2.length(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            part3_ = part3_ + part3_0;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">part3_00</span><span class="params">(part1_.length() - part3_.length(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            part3_ = part3_00 + part3_;</span><br><span class="line">            <span class="built_in">string</span> part4_ = multi(A2, B1);</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">part4_0</span><span class="params">(B2.length(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            part4_ = part4_ + part4_0;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">part4_00</span><span class="params">(part1_.length() - part4_.length(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            part4_ = part4_00 + part4_;</span><br><span class="line">            <span class="keyword">return</span> Plus(part1_, part2_, part3_, part4_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_36165148/article/details/81132525</span></span><br></pre></td></tr></table></figure><p>我还发现一种很有趣的解法大家可以看看：<a href="https://blog.csdn.net/tjsinor2008/article/details/5625849" target="_blank" rel="noopener">https://blog.csdn.net/tjsinor2008/article/details/5625849</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分治法&quot;&gt;&lt;a href=&quot;#分治法&quot; class=&quot;headerlink&quot; title=&quot;分治法&quot;&gt;&lt;/a&gt;分治法&lt;/h1&gt;&lt;h2 id=&quot;分治法的基本思想&quot;&gt;&lt;a href=&quot;#分治法的基本思想&quot; class=&quot;headerlink&quot; title=&quot;分治法的基本思想&quot;&gt;&lt;/a&gt;分治法的基本思想&lt;/h2&gt;&lt;p&gt;分治法的基本思想是将一个大规模的问题划分为若干个小规模的子问题，这些子问题相互独立且与原问题相同。递归的解决这些子问题，然后将各个子问题的解合并得到原问题的解。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
